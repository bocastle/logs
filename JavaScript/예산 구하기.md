# 💰 JavaScript - 예산 (Greedy Algorithm)

## 📝 문제 설명
S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다.  
하지만 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다.  

각 부서가 신청한 금액만큼 **정확히 지원해야** 하며, 일부 금액만 지원하는 것은 허용되지 않습니다.

**신청 금액 배열 `d`와 예산 `budget`이 주어졌을 때**,  
**최대 몇 개의 부서**에 물품을 지원할 수 있는지 return 하도록 `solution` 함수를 완성해주세요.

---

## 📌 제한 사항
- `d`: 신청 금액이 담긴 배열 (길이 1 이상 100 이하)
- 각 신청 금액은 1 이상 100,000 이하의 자연수
- `budget`: 전체 예산 (1 이상 10,000,000 이하)

---

## ✅ 입출력 예

| d             | budget | return |
|---------------|--------|--------|
| [1, 3, 2, 5, 4] | 9      | 3      |
| [2, 2, 3, 3]   | 10     | 4      |
| [5, 6, 7]      | 10     | 1      |

### 예시 설명
- `[1, 3, 2, 5, 4]`에서 금액이 작은 순서대로 `1 + 2 + 3 = 6`까지 가능 → **3개 부서 지원**
- `[2, 2, 3, 3]` → 모두 더해도 `10`이므로 **4개 부서 전부 지원**
- `[5, 6, 7]` → `5`만 지원 가능 → **1개 부서 지원**

---

## 💡 풀이 아이디어

1. 신청 금액이 적은 부서부터 우선적으로 지원하는 것이 유리하다.
2. 금액 배열을 **오름차순 정렬**한다.
3. 예산에서 각 부서의 금액을 빼면서 카운트하고, **예산이 부족해지는 시점에서 종료**한다.

---

## 💻 JavaScript 풀이

```javascript
function solution(d, budget) {
  d.sort((a, b) => a - b); // 신청 금액 오름차순 정렬
  let count = 0;

  for (let cost of d) {
    if (budget >= cost) {
      budget -= cost;
      count++;
    } else {
      break;
    }
  }

  return count;
}