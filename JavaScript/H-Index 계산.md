# H-Index 계산

## 문제 설명

H-Index는 과학자의 논문 중 `h`번 이상 인용된 논문이 `h`편 이상이고, 나머지 논문이 `h`번 이하 인용된 경우의 `h`의 최댓값입니다. 논문의 인용 횟수 배열 `citations`가 주어질 때, 과학자의 H-Index를 반환합니다.

### 입력

- `citations`: 논문별 인용 횟수 배열 (1 ≤ `citations.length` ≤ 1,000, 0 ≤ `citations[i]` ≤ 10,000)

### 출력

- 과학자의 H-Index (정수)

## 해결 코드

```javascript
function solution(citations) {
  // 내림차순 정렬
  citations.sort((a, b) => b - a);

  let h = 0;
  // 인덱스(0-based) + 1이 h번 이상 인용된 논문 수
  for (let i = 0; i < citations.length; i++) {
    if (citations[i] >= i + 1) {
      h = i + 1;
    } else {
      break;
    }
  }

  return h;
}
```

## 코드 설명

1. **정렬**:

   - `citations` 배열을 내림차순으로 정렬하여 높은 인용 횟수부터 확인.
   - 예: `[3, 0, 6, 1, 5]` → `[6, 5, 3, 1, 0]`

2. **H-Index 계산**:

   - 정렬된 배열에서 인덱스 `i`는 0-based이므로, `i + 1`은 해당 위치까지의 논문 수(즉, `h`번 이상 인용된 논문 수).
   - 각 인덱스 `i`에서 `citations[i] >= i + 1`인지 확인:
     - 참이면 `h = i + 1`로 갱신 (최소 `i + 1`편이 `i + 1`번 이상 인용됨).
     - 거짓이면 더 이상 `h`를 증가시킬 수 없으므로 루프 종료.
   - 나머지 논문(`citations[i]` 이후)은 `h`번 이하 인용됨(정렬로 보장).

3. **결과 반환**:
   - 최종 `h` 값을 반환.

### 왜 이 방식이 작동하나?

- 내림차순 정렬 후, `citations[i] >= i + 1`을 만족하는 최대 `i + 1`이 H-Index.
- `i + 1`은 `h`번 이상 인용된 논문 수, `citations[i]`는 해당 논문의 인용 횟수.
- 정렬로 인해 `i` 이후의 논문은 `citations[i]` 이하의 인용 횟수를 가지므로, 나머지 논문이 `h`번 이하라는 조건 자동 만족.

## 예시

### 예시 1

- 입력: `citations=[3, 0, 6, 1, 5]`
- 계산:
  - 정렬: `[6, 5, 3, 1, 0]`
  - `i=0`: `citations[0]=6 >= 1` → `h=1`
  - `i=1`: `citations[1]=5 >= 2` → `h=2`
  - `i=2`: `citations[2]=3 >= 3` → `h=3`
  - `i=3`: `citations[3]=1 < 4` → 종료
- 출력: `3` (3편 이상 인용된 논문 3편, 나머지 2편은 3회 이하)

## 시간 복잡도

- 정렬: `O(n log n)` (`n`은 `citations.length`)
- 순회: `O(n)`
- **총 시간 복잡도**: `O(n log n)`
- **공간 복잡도**: `O(1)` (제자리 정렬 사용 시)

## 제한사항 고려

- `citations.length` ≤ 1,000: `O(n log n)`으로 충분히 처리 가능.
- `citations[i]` ≤ 10,000: 오버플로우 걱정 없음.
- 입력은 항상 유효한 배열.
