# 사과 상자 포장 최대 이익 계산

## 문제 설명

과일 장수는 사과를 상태에 따라 1점(최하품)부터 `k`점(최상품)까지 분류합니다. 사과는 `m`개씩 상자에 포장하며, 상자의 가격은 상자 내 최저 점수 `p`에 `m`을 곱한 값입니다. 사과는 상자 단위로만 판매되며, 남는 사과는 버립니다. 최대 이익을 계산하려 합니다.

### 입력

- `k`: 사과의 최대 점수 (3 ≤ `k` ≤ 9)
- `m`: 한 상자에 들어가는 사과 개수 (3 ≤ `m` ≤ 10)
- `score`: 사과들의 점수 배열 (7 ≤ `score.length` ≤ 1,000,000, 1 ≤ `score[i]` ≤ `k`)

### 출력

- 최대 이익 (정수). 이익이 발생하지 않으면 0 반환.

## 해결 코드

```javascript
function solution(k, m, score) {
  // 점수를 내림차순으로 정렬
  score.sort((a, b) => b - a);

  let totalProfit = 0;

  // m개씩 묶어서 상자 구성
  for (let i = 0; i <= score.length - m; i += m) {
    // 상자의 최저 점수는 m번째 사과
    totalProfit += score[i + m - 1] * m;
  }

  return totalProfit;
}
```

## 코드 설명

1. **점수 정렬**:

   - `score` 배열을 내림차순으로 정렬하여 높은 점수의 사과부터 상자에 담습니다.
   - 이는 최대 이익을 위해 최적의 상자를 구성하기 위함입니다.

2. **상자 구성 및 이익 계산**:

   - `m`개씩 사과를 묶어 상자를 만듭니다.
   - 각 상자의 최저 점수는 `m`번째 사과의 점수(`score[i + m - 1]`)입니다.
   - 상자 가격은 최저 점수 × `m`이며, 이를 `totalProfit`에 더합니다.
   - `i`를 `m`씩 증가시켜 다음 상자를 처리합니다.

3. **종료 조건**:
   - `score.length - m`까지 반복하여 남은 사과가 `m`개 미만이면 상자를 만들지 않습니다.
   - 이익이 없으면 0을 반환합니다(자동으로 처리됨).

## 예시

### 예시 1

- 입력: `k=3`, `m=4`, `score=[1, 2, 3, 1, 2, 3, 1]`
- 계산:
  - 정렬: `[3, 3, 2, 2, 1, 1, 1]`
  - 첫 상자: `[3, 3, 2, 2]` → 최저 점수 2 → 가격: `2 * 4 = 8`
  - 남은 사과 `[1, 1, 1]`은 `m=4` 미만이므로 상자 구성 불가
  - 총 이익: `8`
- 출력: `8`

### 예시 2

- 입력: `k=4`, `m=3`, `score=[4, 1, 2, 2, 4, 4, 4, 4, 1, 2, 4, 2]`
- 계산:
  - 정렬: `[4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 1, 1]`
  - 첫 상자: `[4, 4, 4]` → 최저 점수 4 → 가격: `4 * 3 = 12`
  - 두 번째 상자: `[4, 4, 2]` → 최저 점수 2 → 가격: `2 * 3 = 6`
  - 세 번째 상자: `[2, 2, 2]` → 최저 점수 2 → 가격: `2 * 3 = 6`
  - 남은 사과 `[1, 1]`은 `m=3` 미만이므로 상자 구성 불가
  - 총 이익: `12 + 6 + 6 = 24`
- 출력: `24`

## 시간 복잡도

- 정렬: `O(n log n)` (n은 `score` 배열의 길이)
- 상자 구성 루프: `O(n/m)` → 최악 `O(n)`
- 총 시간 복잡도: `O(n log n)`
- 공간 복잡도: `O(1)` (입력 배열을 제자리 정렬)

## 제한사항 고려

- `score` 길이가 최대 1,000,000이므로 효율적인 정렬 알고리즘이 필요.
- `k`와 `m`은 작으므로(각각 9, 10 이하) 계산에 큰 영향을 주지 않음.
- 이익이 발생하지 않는 경우(예: `score` 길이 < `m`)는 루프가 실행되지 않아 자동으로 0 반환.
