# 짝지어 제거하기

## 문제 설명

알파벳 소문자로 이루어진 문자열 `S`에서 같은 알파벳이 연속으로 두 개 붙어 있는 짝을 찾아 제거하고, 앞뒤 문자열을 이어 붙이는 과정을 반복합니다. 문자열을 모두 제거할 수 있으면 1을, 그렇지 않으면 0을 반환합니다.

### 입력

- `S`: 알파벳 소문자로 이루어진 문자열 (1 ≤ `S.length` ≤ 1,000,000)

### 출력

- 문자열을 모두 제거할 수 있으면 `1`, 그렇지 않으면 `0` (정수)

## 해결 코드

```javascript
function solution(s) {
  const stack = [];

  for (let char of s) {
    if (stack.length > 0 && stack[stack.length - 1] === char) {
      stack.pop();
    } else {
      stack.push(char);
    }
  }

  return stack.length === 0 ? 1 : 0;
}
```

## 코드 설명

1. **스택 기반 접근**:

   - 문자열을 순회하며 스택을 사용해 짝을 관리.
   - 현재 문자(`char`)가 스택의 맨 위 문자와 같으면 짝이므로 `pop`으로 제거.
   - 다르면 스택에 `push`.

2. **알고리즘**:

   - 빈 스택 생성.
   - 문자열 `s`의 각 문자를 순회:
     - 스택이 비어있지 않고, 스택의 맨 위 문자가 현재 문자와 같으면: `pop`.
     - 그렇지 않으면: 현재 문자를 스택에 `push`.
   - 순회 후 스택이 비어있으면 모든 짝이 제거된 것이므로 `1` 반환, 아니면 `0`.

3. **효율성**:
   - 문자열을 한 번 순회하며 각 문자에 대해 `O(1)` 연산(`push` 또는 `pop`).
   - 스택은 최악의 경우 문자열 길이만큼 쌓일 수 있음.

## 예시

### 예시 1

- 입력: `s="baabaa"`
- 계산:
  - 초기: `stack=[]`
  - `b`: `stack=[b]`
  - `a`: `stack=[b, a]`
  - `a`: `stack=[b]` (a-a 짝 제거)
  - `b`: `stack=[]` (b-b 짝 제거)
  - `a`: `stack=[a]`
  - `a`: `stack=[]` (a-a 짝 제거)
- 결과: 스택이 비었으므로 `1`
- 출력: `1`

### 예시 2

- 입력: `s="cdcd"`
- 계산:
  - 초기: `stack=[]`
  - `c`: `stack=[c]`
  - `d`: `stack=[c, d]`
  - `c`: `stack=[c, d, c]`
  - `d`: `stack=[c, d, c, d]`
- 결과: 스택이 비어있지 않으므로 `0`
- 출력: `0`

## 시간 복잡도

- 문자열 순회: `O(n)` (`n`은 문자열 길이)
- 각 문자 처리: `O(1)` (`push` 또는 `pop`)
- **총 시간 복잡도**: `O(n)`
- **공간 복잡도**: `O(n)` (최악의 경우 스택에 모든 문자 저장)

## 제한사항 고려

- `S.length` ≤ 1,000,000: `O(n)`으로 충분히 처리 가능.
- 문자열은 소문자로만 구성: 별도의 문자 처리 불필요.
- 스택을 사용하므로 메모리 효율적.
