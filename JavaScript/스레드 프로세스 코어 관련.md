# 📘 스레드, 프로세스, 코어의 수는 많을수록 좋을까?

> **"스레드, 프로세스, 코어가 많으면 무조건 성능이 좋아지지 않나요?"**

정답은 **"아니오"**입니다. 많다고 무조건 성능이 좋아지는 것이 아니라, **적절하게 활용할 수 있어야** 성능 향상이 가능합니다.

---

## 🧵 스레드 (Thread)

### ✅ 장점
- I/O 중심의 작업 (네트워크, 파일 등)에서 성능 향상
- 공유 메모리를 사용하므로 가볍고 빠른 통신 가능

### ⚠️ 단점
- **컨텍스트 스위칭 비용 증가**
- **락 경합 문제**: 동시성 제어 미흡 시 데드락 발생 가능
- **스택 메모리 등 추가 메모리 사용**
- **디버깅 어려움 증가**

### 💡 정리
> 병렬 I/O 성능에는 유리하지만, 너무 많은 스레드는 오히려 성능 저하를 유발할 수 있음.

---

## 🔧 프로세스 (Process)

### ✅ 장점
- 프로세스 간 **고립성**이 높아 시스템 안정성 증가
- 한 프로세스가 죽어도 다른 프로세스에 영향 없음

### ⚠️ 단점
- 메모리 사용량 증가 (각 프로세스는 독립된 메모리 공간 사용)
- **프로세스 간 통신(IPC) 비용**이 크다
- 생성 및 스위칭 오버헤드가 크다

### 💡 정리
> 안정성과 보안이 필요한 경우에 적절하지만, 너무 많은 프로세스는 오히려 오버헤드로 성능 저하 발생

---

## 🧠 코어 (CPU Core)

### ✅ 장점
- 병렬 연산에 강함 (멀티스레드, 멀티프로세스 환경)
- 고성능 백엔드 시스템에 필수적

### ⚠️ 단점
- 단일 스레드 작업이 주를 이루는 경우 활용도 낮음
- 전력 소모 및 발열 증가
- 캐시나 메모리 대역폭은 공유 → 병목 가능성 존재

### 💡 정리
> 병렬 처리가 많은 경우에 매우 유리. 다만, 소프트웨어가 멀티코어 최적화되어 있어야 효과적

---

## ✅ 결론 요약

| 리소스   | 많을수록 좋은가? | 유리한 상황               | 주의사항                       |
|----------|------------------|----------------------------|--------------------------------|
| 스레드   | ❌ (과하면 독)    | I/O 중심, 동시성 처리      | 락 관리, 컨텍스트 스위칭 비용 |
| 프로세스 | ❌ (과하면 독)    | 안정성, 격리성 요구되는 경우| 메모리, IPC 오버헤드           |
| 코어     | ⭕ (조건부 좋음)  | 병렬 처리 최적화된 앱      | 멀티코어 최적화 필요           |

---

## 🧪 실무에서의 활용 팁

- Node.js: 싱글 스레드 → 클러스터링으로 멀티코어 활용
- Java/Go/Python: 멀티스레드 및 스레드풀 사용 → 동기화 신경 써야 함
- 일반적으로 CPU 코어 수 × 2 정도의 스레드로 시작해서 튜닝
- 병렬 작업에 적합하도록 아키텍처 설계 필요 (ex. 비동기 처리, 큐, worker 분산)
