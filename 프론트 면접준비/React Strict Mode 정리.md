# React Strict Mode 정리 (React 18 기준)

---

## 1) 목적과 적용 방법

- **목적**

  - 오래된/위험한 API 사용 감지
  - **렌더의 순수성**과 **이펙트의 안전성** 검증
  - 향후 React 기능(동시성 등)에 안전한 코드베이스로 유도

- **적용**

  ```jsx
  import React from "react";
  import { createRoot } from "react-dom/client";

  createRoot(document.getElementById("root")).render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
  ```

  - 트리 **일부에만** 감싸서 점진적으로 적용할 수 있습니다.

---

## 2) 무엇을 점검하는가

- **비권장/레거시 API 사용**
  - 클래스 컴포넌트의 **Unsafe 라이프사이클**(`componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`)
  - **문자열 refs**(string refs), **`findDOMNode`**, **구 레거시 Context** 등
- **렌더 순수성 검증**
  - 컴포넌트 본문(렌더 단계)에서 **부수 효과**(구독, 타이머 시작, 네트워크 호출 등)를 실행하면 경고/이상 징후 노출
- **이펙트 안전성 검증(React 18 Strict Effects)**
  - `useEffect`/`useLayoutEffect` **setup → cleanup → setup** 순으로 **즉시 재실행**하여
    - **클린업 누락**,
    - **구독/타이머 중복 등록**,
    - **비결정적(side effectful) 코드**
      를 조기 발견
- **의심스러운 동작**
  - **중복 키**, **예측 불가한 상태 공유**, **Deprecated API** 접근 등

> 개발 모드에서만 활성화되며, 빌드 시 제거됩니다.

---

## 3) “두 번 실행”의 정확한 의미

- **대상**: 개발 모드 + StrictMode 하에서
  - 함수 컴포넌트 본문, `useMemo`/`useCallback` 계산 등 **렌더 단계 코드가 한 번 더 호출**될 수 있습니다.
  - 이펙트는 **즉시 언마운트 후 다시 마운트**됩니다(Setup → Cleanup → Setup).
- **목적**: **순수성 보장**과 **클린업 누락 탐지**.  
  예를 들어, 이펙트에서 WebSocket을 여는 코드가 있다면 **두 번째 실행 전에 반드시 첫 번째 구독을 닫아야** 합니다.
- **프로덕션 영향**: 없음(프로덕션에서는 **한 번만** 실행).

---

## 4) 데이터 패칭·사이드 이펙트 모범 사례

- **렌더 단계에서 네트워크 호출 금지**: 컴포넌트 본문은 **순수 계산**만 수행
  - 데이터 패칭은 `useEffect`(클라이언트) 또는 **서버 컴포넌트/라우터 로더**로 위임
- **이펙트 클린업 필수**
  ```jsx
  useEffect(() => {
    const id = setInterval(tick, 1000);
    return () => clearInterval(id); // cleanup
  }, []);
  ```
- **구독/이벤트 리스너**는 등록·해제 쌍을 보장
- **타이머/애니메이션/MutationObserver** 등 **모든 외부 리소스**는 클린업에서 해제
- **idempotent(멱등) 이펙트** 설계: 두 번 연속 실행해도 **중복 부작용이 없도록** 작성

---

## 5) 서드파티/레거시 코드 호환 전략

- 외부 라이브러리가 **이펙트 두 번 실행**을 가정하지 않았다면
  - **클린업 철저**: `destroy()`/`unsubscribe()`/`abort()` 제공 여부 확인
  - **인스턴스 단일화**: `useRef`로 외부 인스턴스 보관 후, **존재하면 재생성 금지** 패턴 적용
  - 필요한 경우 해당 부분만 **StrictMode 범위에서 제외**하여 점진 개선
- **문자열 refs → 함수/객체 refs**로 이전
- **findDOMNode** 대신 **ref** 직접 바인딩 또는 **`forwardRef`** 사용

---

## 6) 자주 묻는 질문

- **Q. 개발 중 성능 저하가 느껴집니다.**  
  A. 개발 모드의 **추가 호출/검사 비용** 때문입니다. 이는 **문제 탐지를 위한 의도된 비용**이며, 프로덕션 빌드에는 반영되지 않습니다.
- **Q. “두 번 렌더” 경고가 보입니다. 버그인가요?**  
  A. StrictMode의 **검증 동작**입니다. 렌더와 이펙트가 **순수/멱등**한지 점검하십시오.
- **Q. 일부 효과가 두 번 트리거되는 것을 막을 수 있나요?**  
  A. 개발 모드에서는 막지 않는 것이 원칙입니다. 대신 **클린업 정확성**을 확보하세요.

---

## 7) 체크리스트

- [ ] 렌더 단계에 **사이드 이펙트**가 없는가
- [ ] `useEffect`/`useLayoutEffect`에 **정확한 클린업**이 있는가
- [ ] **Deprecated API**(문자열 refs, `findDOMNode`, Unsafe 라이프사이클)를 사용하지 않는가
- [ ] 외부 리소스(WebSocket, EventSource, 타이머, Observer)를 **중복 없이** 관리하는가
- [ ] StrictMode를 **부분 적용**하여 점진적으로 코드 품질을 개선하고 있는가

---

## 8) 요약

- StrictMode는 **개발 전용 안전망**으로, 렌더 순수성과 이펙트의 클린업을 강제 점검합니다.
- **두 번 실행**은 **개발 중에만** 발생하며, 프로덕션 성능/동작에는 영향을 주지 않습니다.
- 모범 사례(순수 렌더, 멱등 이펙트, 철저한 클린업)를 지키면 **동시성·미래 기능**에도 견고한 코드가 됩니다.
