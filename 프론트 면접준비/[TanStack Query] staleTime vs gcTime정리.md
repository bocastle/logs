# TanStack Query: `staleTime` vs `gcTime` 정리

> 본 문서는 TanStack Query v5 기준으로 작성되었습니다. (v4의 `cacheTime`은 v5에서 `gcTime`으로 이름만 변경되었습니다.)

## 한눈에 보기

| 항목          | 의미                                                               | 기본값            | 언제 영향                                | 네트워크 요청 여부                                                    |
| ------------- | ------------------------------------------------------------------ | ----------------- | ---------------------------------------- | --------------------------------------------------------------------- |
| **staleTime** | 데이터가 **신선(fresh)** 하다고 간주되는 기간                      | `0ms`             | 쿼리 인스턴스가 **마운트되어 있는 동안** | 신선 상태에서는 **자동 재요청 억제**, 수동 refetch는 가능             |
| **gcTime**    | 쿼리를 쓰는 컴포넌트가 **모두 언마운트된 뒤** 캐시를 보관하는 기간 | `5분 (300,000ms)` | **마지막 구독 해제 이후**                | 캐시만 유지, 요청은 발생하지 않음 (재구독 시 캐시가 있다면 즉시 표시) |

---

## 핵심 차이

- **staleTime은 “데이터의 신선도”** 를, **gcTime은 “캐시의 보존 기간”** 을 제어합니다.
- **staleTime이 지나도 데이터는 삭제되지 않습니다.** 단지 *stale*로 간주될 뿐이며, 트리거(포커스, 재마운트 등) 시 **재요청 후보**가 됩니다.
- **gcTime이 지나면 캐시가 삭제**되므로, 같은 쿼리로 다시 마운트될 때 **초기 로딩**부터 시작합니다.

---

## 동작 타임라인(예시)

```
t=0ms     : 쿼리 최초 성공 → fresh 상태 시작
t=20s     : staleTime=20s 이라면 여기서 stale 전환 (데이터는 남아있음)
t=30s     : 포커스/재마운트/네트워크 재연결 등 트리거 시, stale이므로 refetch 시도
t=45s     : 해당 쿼리를 쓰는 마지막 컴포넌트 언마운트
t=45s~+5m : gcTime=5m 동안 캐시 유지(화면엔 안 보이지만 메모리에 존재)
t=+5m 경과: 캐시 삭제
```

---

## 설정 가이드(상황별 권장 값)

- **거의 변하지 않는 정적/준정적 데이터(피처 플래그, 국가코드표 등)**
  - `staleTime: 5~60분` 또는 더 길게
  - `gcTime: 기본값` (5분) 또는 더 길게(자주 이동하는 화면이면 10~30분)
- **분 단위로 변하는 목록/통계(대시보드, 주문 현황 등)**
  - `staleTime: 10~60초`
  - `refetchInterval`(선택)과 조합
- **초 단위의 실시간성(채팅, 티커 등)**
  - `staleTime: 0~5초`
  - `refetchInterval` 또는 WebSocket으로 보완
- **무거운 쿼리(응답이 커서 비용이 큼)**
  - `staleTime`을 넉넉히 잡아 **자동 재요청 빈도 감소**
  - `gcTime`도 길게 두어 **뒤로 가기/재방문 시 즉시 화면 표시**

> 규칙: _“자주 변하지 않는 데이터일수록 staleTime을 늘리고, 사용자가 화면을 오갈 때 빠른 복귀가 필요하면 gcTime을 늘린다.”_

---

## 흔한 오해와 정답

1. **staleTime이 지나면 캐시가 삭제된다?** → **아닙니다.** 삭제는 `gcTime`이 담당합니다.
2. **staleTime 동안엔 수동 재요청도 막히나?** → **아닙니다.** `refetch()`는 언제든 가능합니다.
3. **컴포넌트가 없어도 staleTime이 흐르나?** → **staleTime은 신선도 규칙**이고, 구독 여부와 무관합니다. 다만 실제 재요청은 **구독 중에만** 의미가 있습니다.
4. **gcTime이 0이면?** → 언마운트 즉시 캐시 삭제(뒤로 가기 시 매번 초기 로딩).

---

## Tip

- **초기 표시 품질**: `placeholderData` vs `initialData`
  - `initialData`는 *첫 페인트용 실제 데이터*처럼 취급되어 **staleTime 카운트도 시작**됩니다.
  - `placeholderData`는 *스켈레톤 대용*이며 신선도 카운트를 시작하지 않습니다.
- **사용자 체감 최적화**:
  - 페이지 전환이 잦다면 **gcTime을 넉넉히** → 돌아왔을 때 즉시 캐시 표시.
  - 데이터가 자주 바뀌지 않으면 **staleTime을 넉넉히** → 불필요한 재요청 감소.
- **자동 트리거 제어**: `refetchOnWindowFocus`, `refetchOnReconnect`, `refetchOnMount`를 **staleTime과 함께** 조절하세요. 신선 상태에서는 자동 refetch가 억제됩니다.
- **버전 주의**: v4 문서의 `cacheTime`은 v5에서 **`gcTime`** 으로 이름만 변경되었습니다. 의미는 동일합니다.

---

## 코드 예시 (TypeScript)

### 1) 전역 기본값

```ts
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 신선도: 1분
      staleTime: 60 * 1000,
      // 언마운트 후 캐시 보존: 10분
      gcTime: 10 * 60 * 1000,
      // 포커스 시 자동 재요청은 stale일 때만
      refetchOnWindowFocus: true,
    },
  },
});
```

### 2) 쿼리별 오버라이드

```ts
const { data } = useQuery({
  queryKey: ["user", userId],
  queryFn: getUser,
  staleTime: 5 * 60 * 1000, // 사용자 정보는 비교적 안정 → 5분
  gcTime: 30 * 60 * 1000, // 마이페이지로 자주 왕복 → 30분 보존
});
```

### 3) 비용이 큰 목록과 인터벌 조합

```ts
useQuery({
  queryKey: ["orders", { status }],
  queryFn: fetchOrders,
  staleTime: 30 * 1000,
  refetchInterval: 30 * 1000, // 주기 갱신(포커스/가시성 정책과도 상호작용)
  refetchIntervalInBackground: false, // 백그라운드 과도한 호출 방지
});
```

---

## 마지막 체크리스트

- [ ] 바뀜이 드문가? → **staleTime 길게**
- [ ] 화면 왕복이 잦은가? → **gcTime 길게**
- [ ] 자동 트리거가 과도한가? → `refetchOn*` 옵션 조정
- [ ] 초기 경험이 중요한가? → `initialData`/`placeholderData` 적절히 선택

---

## 요약

- **staleTime**: “데이터가 신선하다고 간주되는 시간” → 신선하면 자동 재요청이 억제됩니다.
- **gcTime**: “구독이 끊긴 뒤 캐시를 보존하는 시간” → 지나면 캐시가 **삭제**됩니다.
- 서로 목적이 다르므로 **둘 다 의도적으로 설계**해야 최고의 UX와 성능을 얻을 수 있습니다.
