# 커링(Currying) 정리

## 문제

프론트엔드 개발에서 재사용성과 가독성을 높이기 위해 커링(currying)을 활용할 수 있습니다. 하지만 무조건 장점만 있는 것은 아니며, 상황에 따라 단점도 존재합니다.

---

## 특징

- **정의**: 여러 개의 인자를 받는 함수를, 단일 인자를 받는 함수들의 체인 형태로 변환하는 기법.
- **형태 변환 예시**:
  - 일반 함수: `f(a, b, c)`
  - 커링 함수: `f(a)(b)(c)`

---

## 장점

1. **재사용성 증가**
   - 부분 적용(Partial Application)이 가능하여, 특정 인자를 고정한 새로운 함수를 쉽게 만들 수 있음.
   - 예시:
     ```js
     const isGreaterThan = (min) => (value) => value > min;
     const greaterThan30 = numbers.filter(isGreaterThan(30));
     ```
2. **함수 합성에 유리**

   - `pipe`, `compose` 같은 함수형 유틸리티와 결합하여 읽기 좋은 데이터 처리 파이프라인 작성 가능.
   - 예시:
     ```js
     const process = pipe(add(2), square, toString);
     console.log(process(3)); // "25"
     ```

3. **코드 가독성 개선**
   - “의도를 드러내는 코드” 작성에 유리 (예: `filter(isGreaterThan(30))` 는 조건을 명확히 표현).

---

## 단점

1. **가독성 저하 (과도한 커링 사용 시)**

   - 단순한 연산에까지 커링을 남용하면 `f(a)(b)(c)` 형태가 오히려 직관성을 해칠 수 있음.

2. **디버깅 난이도 증가**

   - 함수가 여러 단계로 분리되어 있어, 에러가 발생한 지점을 추적하기 어려움.

3. **성능 이슈 (경우에 따라)**

   - 커링된 함수는 매번 새로운 클로저를 생성하므로, 대규모 연산 시 불필요한 메모리 사용이 증가할 수 있음.

4. **JS 문법과 혼동 가능**
   - 초급자 입장에서는 `f(a)(b)` 같은 문법이 일반적인 함수 호출과 달라 이해가 어려울 수 있음.

---

## 최적화

- **필요한 경우에만 커링 적용**

  - 부분 적용이나 합성의 필요성이 있는 경우 → 커링 적극 활용.
  - 단순한 함수는 일반적인 다중 인자 함수로 두는 것이 더 낫다.

- **유틸리티 함수와 함께 사용**
  - `lodash/fp`, `ramda` 같은 함수형 라이브러리에서는 기본적으로 커링이 적용되어 있어, 함수 합성과 함께 효율적으로 활용 가능.

---

## 결론

- 커링은 **재사용성, 함수 합성, 가독성** 측면에서 프론트엔드 코드의 품질을 높여줄 수 있는 강력한 기법이다.
- 하지만 무조건적으로 쓰기보다는, **의도를 드러낼 때와 합성·재사용에 이점이 있는 상황에서 선택적으로 활용**하는 것이 바람직하다.
- 결국 “적재적소에서의 균형 잡힌 사용”이 커링의 핵심이다.
