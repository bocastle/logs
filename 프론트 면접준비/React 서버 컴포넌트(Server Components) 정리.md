# React 서버 컴포넌트(Server Components) 정리

## 개요

- **정의**: 서버에서만 렌더링되는 React 컴포넌트. 브라우저로 JS 번들을 보내지 않고 **HTML/직렬화된 RSC 페이로드**만 전송합니다.
- **도입 배경**: 초기 로딩 지연, 과도한 번들 크기, 데이터 패칭/보안 문제를 해소하기 위함.
- **사용 환경**: React 18 기반. Next.js(App Router) 등 서버 프레임워크에서 주로 사용.

---

## 동작 원리

1. 서버에서 RSC 트리를 렌더 ⇒ **RSC Payload(컴포넌트 트리의 직렬화 결과)** 생성.
2. 클라이언트는 이 페이로드를 받아 **클라이언트 컴포넌트**와 결합하여 화면을 구성.
3. 이벤트 핸들러가 필요한 구간만 `"use client"` 컴포넌트로 분리하여 번들링.

> 서버 컴포넌트는 브라우저 전용 API(`window`, `document`, 이벤트 핸들러 등)를 사용할 수 없습니다.

---

## 장점

- **번들 크기 감소**: 서버 전용 코드가 클라이언트 번들에 포함되지 않습니다.
- **빠른 초기 표시**: 네트워크 왕복/JS 실행 이전에 중요한 UI를 전달 가능. Streaming/Partial Rendering과 궁합이 좋습니다.
- **데이터 패칭 최적화**: DB·외부 API를 서버에서 직접 호출하여 **N+1** 감소, 중복 요청 제거, 캐싱 전략 일원화.
- **보안 강화**: 비밀 키/DB 커넥션 정보가 클라이언트로 노출되지 않습니다.
- **개발 생산성**: 데이터 의존 UI를 서버에 가깝게 배치해 복잡한 상태 동기화 코드를 줄일 수 있습니다.

---

## 한계 및 주의점

- **인터랙션 제약**: 이벤트 핸들러, 상태 기반 상호작용은 **클라이언트 컴포넌트**에서만 가능합니다.
- **서버 의존성**: 서버 가용성/지연에 직접 영향. 정적 호스팅만으로는 활용이 제한됩니다.
- **경계 설계 필요**: 서버/클라이언트 경계 분리가 미흡하면 데이터가 중복 요청되거나 수화(hydration) 타이밍 문제가 생길 수 있습니다.
- **직렬화 제약**: 서버에서 클라이언트로 전달되는 props는 **직렬화 가능**해야 합니다(Date/Map/함수 등은 변환 필요).
- **빌드/배포 복잡성**: RSC 전용 번들, 클라이언트 번들, 라우팅/캐싱 규칙을 함께 관리해야 합니다.

---

## 서버 vs 클라이언트 컴포넌트의 역할 분리

| 구분              | 서버 컴포넌트                       | 클라이언트 컴포넌트                  |
| ----------------- | ----------------------------------- | ------------------------------------ |
| 주 역할           | 데이터 패칭, 접근 제어, 마크업 생성 | 이벤트 핸들링, 로컬 상태, 애니메이션 |
| 번들 포함         | 포함 안 됨                          | 브라우저로 전송                      |
| 사용할 수 없는 것 | 브라우저 API, 이벤트 핸들러         | 제한 없음                            |
| 적합 사례         | 리스트/상세 렌더링, SEO 영역        | 폼 입력, 드래그·드롭, 모달 제어      |

---

## Next.js(App Router) 예시 패턴

```tsx
// 서버 컴포넌트 (기본)
export default async function ProductsPage() {
  const products = await getProducts(); // DB/API 호출
  return (
    <main>
      <h1>Products</h1>
      <ProductList products={products} /> // 서버 컴포넌트로 전달
      <AddToCartButton productId={products[0].id} /> {/* 클라이언트 컴포넌트 */}
    </main>
  );
}

// 클라이언트 컴포넌트
("use client");
import { useTransition } from "react";

export function AddToCartButton({ productId }: { productId: string }) {
  const [pending, start] = useTransition();
  return (
    <button
      disabled={pending}
      onClick={() => start(() => addToCart(productId))}
    >
      {pending ? "Adding..." : "Add to cart"}
    </button>
  );
}
```

- 서버/클라이언트 컴포넌트를 **작게** 나눠 핵심 UI는 서버에서, 상호작용은 클라이언트에서 맡깁니다.
- 서버 액션(Next.js)과 결합하면 폼/버튼이 서버 함수를 직접 호출해 **API 계층 간소화**가 가능합니다.

---

## 캐싱과 데이터 일관성

- **요청 단위 캐싱**(Request memoization)과 **서버 캐시**를 조합해 중복 패칭을 줄입니다.
- 라우트 세그먼트/데이터 페치에 적절한 **revalidate**(ISR)/**cache** 옵션을 적용합니다.
- 클라이언트 상태 라이브러리(TanStack Query 등)와 함께 쓸 때는 **서버에서 초깃값을 주입**하고 클라이언트에서 점진적 갱신을 수행합니다.

---

## Streaming/Hydration 연계

- 서버 컴포넌트 출력은 **Streaming SSR**과 자연스럽게 결합됩니다.
- 부분 수화(Partial Hydration)로 클라이언트 컴포넌트만 필요한 범위에서 수화되어 **TTFB는 빠르게, TTI 격차는 최소화**합니다.
- 수화 불일치 방지를 위해 서버/클라이언트가 **동일한 데이터 소스**를 읽도록 구성합니다.

---

## 안티패턴 및 체크리스트

- 서버 컴포넌트에서 **브라우저 전용 로직** 사용 시도 금지.
- 불필요한 클라이언트 컴포넌트 분리 지양(번들 증가). 이벤트가 없는 단순 표시 컴포넌트는 서버로 이동.
- 직렬화 불가능한 데이터를 그대로 props로 전달하지 않기.
- 경계가 깊게 중첩되어 **fallback 깜박임**이 잦다면 Suspense 배치/그룹 구성을 조정.

---

## 언제 서버 컴포넌트를 쓰면 좋은가

- SEO가 중요한 문서형/리스트형 페이지
- 대량 데이터 조회 후 **가공·필터링**이 많은 뷰
- 비공개 키/민감 자원 접근이 필요한 렌더링 경로
- 초기 로딩/번들 크기 최적화가 목표일 때

## 언제 클라이언트 위주가 적합한가

- 폼 위주의 즉각 상호작용, 드래그·드롭·리치 에디팅
- 고빈도 애니메이션/캔버스/웹소켓 실시간 상호작용

---

## 마이그레이션 팁

1. **표시 전용 컴포넌트**부터 서버로 이동.
2. 이벤트가 필요한 최소 경계만 `"use client"`로 유지.
3. 데이터 패칭을 서버로 끌어올리고 캐시 정책을 명시.
4. Streaming/Suspense를 도입해 지각 로딩 구간을 매끄럽게 처리.

---

## 결론

서버 컴포넌트는 **번들 절감·보안·데이터 패칭** 면에서 큰 이점을 제공하며, 클라이언트 컴포넌트와의 **역할 분리**를 통해 UX와 성능을 동시에 개선할 수 있습니다. 다만 경계 설계, 직렬화 제약, 수화 타이밍을 정확히 이해하고 적용해야 최적의 효과를 얻을 수 있습니다.
