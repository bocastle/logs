# CSS에서 위치를 동적으로 변경할 때: `transform` vs `position`(top/left)

## 결론

- **애니메이션/드래그/호버 등 “움직이는 연출” 목적**이라면 보통 **`transform`(및 `opacity`)을 우선 선호**합니다.
- **레이아웃(문서 흐름) 자체를 바꾸거나 기준 좌표계가 필요한 배치**라면 **`position`(top/left/right/bottom) 또는 레이아웃 속성**을 사용합니다.

---

## 왜 보통 `transform`을 선호하나

### 1) 렌더링 비용 관점(성능)

브라우저 렌더링 파이프라인은 일반적으로 다음 단계로 생각할 수 있습니다.

- **Layout(Reflow)**: 요소의 크기/위치 계산
- **Paint(Repaint)**: 픽셀 그리기
- **Composite**: 레이어 합성(최종 화면 구성)

`transform`은 대개 **layout을 다시 계산하지 않고**, 이미 그려진 결과를 **합성 단계에서 이동/회전/스케일**하므로,

- **Layout(Reflow) 유발 가능성이 낮고**
- **Paint 비용도 줄어드는 경우가 많아**
- **프레임 드랍이 줄어듭니다.**

특히 “자주/연속적으로” 변하는 애니메이션(hover, scroll-driven, drag)에서 체감이 큽니다.

### 2) 자연스러운 애니메이션 구현

CSS transition/animation과 결합 시 `transform`은 부드러운 모션을 만들기 쉽고, 주변 레이아웃을 흔들지 않습니다.

---

## `position`(top/left)을 선호/필요로 하는 경우

`top/left` 등은 **실제 레이아웃 좌표를 바꾸는 방식**이기 때문에, 주변 요소의 배치/흐름에 영향을 줄 수 있습니다.  
따라서 다음 상황에서는 `position`이 맞는 선택일 수 있습니다.

- **문서 흐름/배치 자체를 바꿔야 하는 UI**
  - 예: 특정 요소를 위로 올리면 아래 요소가 “따라 올라오게” 만들고 싶다(레이아웃 재배치)
- **정확한 기준 좌표계가 필요한 배치**
  - 예: 툴팁/드롭다운을 특정 컨테이너 기준으로 배치(`position: absolute; inset/...`)
- **`fixed`, `sticky` 같은 고정/고정형 레이아웃**
  - 스크롤과 결합된 고정 위치는 `position` 영역입니다.

> 주의: “단순히 시각적으로만 조금 움직이고 싶다”면 `position`으로 움직일 이유가 거의 없습니다.

---

## 중요한 차이점(실무에서 자주 마주치는 포인트)

### 1) 문서 흐름(레이아웃)에 영향

- `transform`: **시각적으로만 이동**, **원래 자리(레이아웃 박스)는 그대로**
- `top/left`: **레이아웃 계산에 개입**(상황에 따라 reflow/paint 유발)

### 2) 이벤트/클릭 영역

대부분의 경우 `transform`으로 이동하면 **시각적 위치와 히트 영역도 함께 이동**하지만, 레이아웃 기반 계산(예: 주변 요소 배치)은 그대로라서

- “공간은 원래 자리에 남아 있는데 화면에서는 이동한 것처럼” 보일 수 있습니다.
- 따라서 레이아웃상 공간을 실제로 옮겨야 하면 `transform`은 부적절합니다.

### 3) 스태킹 컨텍스트/레이어

`transform`은 종종 새로운 stacking context를 만들고(케이스에 따라),
성능 최적화를 위해 합성 레이어가 생길 수 있습니다. 이는 z-index/겹침 이슈를 바꿀 수 있습니다.

---

## 추천 패턴

### 1) “움직이는 연출”은 transform으로

```css
.button {
  transition: transform 150ms ease;
}
.button:hover {
  transform: translateY(-5px);
}
```

### 2) “배치/레이아웃”은 position 또는 레이아웃 속성으로

```css
.container {
  position: relative;
}
.tooltip {
  position: absolute;
  top: 100%;
  left: 0;
}
```

### 3) 성능 팁(선택적으로)

- 애니메이션 대상이 명확하고 잦다면 `will-change: transform;`을 고려할 수 있으나 **남발하면 메모리/레이어 비용이 증가**할 수 있습니다.
- 자바스크립트로 연속 이동(드래그 등)을 구현할 때는 **`transform` + `requestAnimationFrame`** 조합이 안정적입니다.

---

## 정리

- **연출/애니메이션 목적(자주 변함)**: `transform` 우선
- **레이아웃/배치 목적(흐름이 바뀌어야 함)**: `position`(또는 flex/grid 등 레이아웃 속성)
