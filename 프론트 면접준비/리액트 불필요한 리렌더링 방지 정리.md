# 리액트 불필요한 리렌더링 방지 정리

> 요약: **리렌더 원인**을 파악(상태 변경·props 참조 변경·컨텍스트 변경)하고, **참조 안정화**·**계산 결과/컴포넌트 메모이제이션**·**상태 배치/분리**·**컨텍스트 분할**을 통해 **필요한 컴포넌트만** 다시 그리도록 설계합니다. 최적화는 **Profiler 측정 기반**으로 선별 적용하십시오.

---

## 1) 리렌더링이 발생하는 대표 원인

- 부모의 **state set**으로 트리 하위 전체가 다시 렌더(자식 props가 동일해도 함수/객체 리터럴로 **참조가 변하면** 리렌더).
- **컨텍스트 값 변경** 시 해당 컨텍스트를 구독하는 모든 하위 컴포넌트가 리렌더.
- **불변성 위반**으로 얕은 비교 실패(배열/객체를 **직접 변경**).
- **키(key)** 부적절 사용(인덱스 key로 인해 노드 재사용 실패, 상태 재설정).
- **파생 상태**를 중복 보관해 동기화 비용 증가.

---

## 2) 핵심 대책

### 2.1 컴포넌트 메모이제이션: `React.memo`

```tsx
const Item = React.memo(function Item({ value }) {
  return <li>{value.label}</li>;
});
// 필요 시 커스텀 비교
export default React.memo(
  Row,
  (prev, next) => prev.row.id === next.row.id && prev.selected === next.selected
);
```

- **전제**: props가 **얕은 비교로 동일**해야 이점 존재. 변동이 잦거나 화면이 간단하면 오버헤드만 증가.

### 2.2 참조 안정화: `useCallback` / `useMemo`

```tsx
const handleClick = useCallback(() => submit(form), [form]);
const columns = useMemo(() => buildColumns(schema), [schema]);
```

- 자식에게 내려가는 **함수·객체·배열**의 참조가 매 렌더마다 바뀌지 않도록.
- 과도 사용 금지: **계산 비용이 크거나** 자주 재생성되어 **실제 리렌더를 유발**하는 경우에만.

### 2.3 상태 관리: **배치/분리/상향·하향 조정**

- **상태 배치(setState batching)**: 관련 상태는 **하나의 객체/리듀서**로 묶어 불필요한 다중 리렌더 방지.
- **상태 분리**: 서로 독립인 상태를 분리해 **변경 범위를 축소**.
- **상태의 위치 조정**: 필요한 **최소 범위**에 상태를 두어 상위 변경이 광범위하게 퍼지지 않도록.

### 2.4 컨텍스트 최적화

- **값을 분할**: 자주 바뀌는 값과 고정 값을 **서로 다른 Context**로 분리.
- 컨텍스트 값에 **객체/함수**를 직접 넣지 말고 `useMemo/useCallback`으로 **안정화**.
- 대안: **selector 기반 컨텍스트**(예: Zustand selector, `useContextSelector`)를 검토.

### 2.5 불변성 유지

```ts
// 나쁨
state.items.push(newItem);
// 좋음
setState((s) => ({ ...s, items: [...s.items, newItem] }));
```

- 불변 업데이트로 얕은 비교가 **정확히 동작**하도록 하여 `React.memo` 효과 극대화.

### 2.6 리스트 렌더링

- **안정적 key** 사용(고유 ID). **index key**는 삽입/삭제/정렬 시 불필요한 리마운트 유발.
- 아이템이 매우 많다면 **가상 스크롤링**(react-window/react-virtualized)로 DOM 수를 제한.

### 2.7 이벤트 핸들러/프롭 패턴

- JSX에 **인라인 객체/함수** 생성 지양:

```tsx
// 나쁨
<Child style={{ color: "red" }} onClick={() => doSomething(x)} />;
// 개선
const style = useMemo(() => ({ color: "red" }), []);
const onClick = useCallback(() => doSomething(x), [x]);
<Child style={style} onClick={onClick} />;
```

- 자식이 `React.memo`일 때 효과가 큼.

### 2.8 선택적 메모이제이션 + 셀렉터

- 전역 상태(Redux/Zustand)는 **selector + memoized equality**(`shallow`, `useSelector`의 `equalityFn`)로 **부분 구독**.
- **reselect** 등으로 파생 데이터 계산 결과 캐시.

### 2.9 비동기/데이터 패칭

- React Query 등에서 **`select` 옵션**으로 필요한 필드만 매핑하여 **리렌더 범위 축소**.
- Suspense 사용 시 경계 배치로 **변경 영향 면적**을 작게 유지.

### 2.10 DOM 레퍼런스/비시각 상태

- 시각적 렌더와 무관한 값(타이머, 외부 인스턴스, 이전 값)은 **`useRef`**에 보관하여 렌더 트리거 회피.

---

## 3) Profiler 기반 최적화 절차

1. **React DevTools Profiler**로 **어떤 컴포넌트가 자주/오래** 리렌더되는지 확인.
2. 원인 파악: **props 참조 변경? 컨텍스트 변화? 상태 위치?** 를 추적.
3. 목표 설정: p95 렌더 시간/프레임 드랍 등 **지표** 정의.
4. **국지적 적용**: `React.memo`·`useMemo`·`useCallback`·상태/컨텍스트 분리.
5. 재측정 후 **회귀 검사**. 이득이 미미하면 복잡도 증가를 피하고 되돌림.

---

## 4) 안티패턴 체크리스트

- [ ] **index key** 사용으로 리스트 상태가 **자주 초기화**된다.
- [ ] 작은 컴포넌트에 **무분별한 메모이제이션**으로 오히려 비용 증가.
- [ ] 컨텍스트에 **매 렌더마다 새 객체/함수**를 전달한다.
- [ ] **불변성 위반**으로 얕은 비교가 실패한다.
- [ ] 상위에 과도한 상태를 두어 **과대 리렌더**가 발생한다.

---

## 5) 예시: 검색 리스트 최적화

```tsx
const Row = React.memo(function Row({
  item,
  onSelect,
}: {
  item: Item;
  onSelect: (id: string) => void;
}) {
  return <li onClick={() => onSelect(item.id)}>{item.label}</li>;
});

function List({ items, onSelect }: Props) {
  const onSelectStable = useCallback((id: string) => onSelect(id), [onSelect]);
  return (
    <ul>
      {items.map((it) => (
        <Row key={it.id} item={it} onSelect={onSelectStable} />
      ))}
    </ul>
  );
}
```

- `Row`는 `React.memo`로 보호, `onSelectStable`로 **콜백 참조 안정화**, `key`는 **고유 ID** 사용.

---

## 결론

- 최적화는 **측정 기반**으로, **참조 안정화 + 메모이제이션 + 상태/컨텍스트 분리**를 조합하여 **필요한 부분만** 리렌더하도록 설계하십시오. 과잉 적용은 복잡도와 비용만 늘릴 수 있으므로, **병목 지점** 위주로 선별 적용하는 것이 바람직합니다.
