# HTTP의 ETag에 대해서

프론트엔드와 관련된 질문이에요.  
ETag(Entity Tag)는 **HTTP 프로토콜에서 사용되는 헤더**로, 웹 리소스의 특정 버전을 식별하는 고유한 식별자입니다.

---

## 📌 ETag의 동작 방식

- 서버가 클라이언트에게 리소스를 전송할 때 **ETag 헤더**를 포함시킵니다.
- 클라이언트는 이후 요청 시 **If-None-Match 헤더**에 이 값을 포함하여 **조건부 요청**을 보냅니다.
- 서버는 클라이언트의 ETag 값과 현재 리소스를 비교해서:
  - 동일 → `304 Not Modified` 응답 (리소스를 다시 다운로드하지 않음)
  - 다름 → 새 리소스를 전송

👉 이를 통해 **네트워크 트래픽 절감** 및 **서버 부하 감소** 효과가 있습니다.

---

## 📌 ETag vs Last-Modified

- **Last-Modified**: 타임스탬프 기반 (파일 수정 시각 비교)
- **ETag**: 콘텐츠 기반 (해시값, 버전 번호 등)
- 차이점:
  - `Last-Modified`는 1초 이내 변경이나 시간 비교가 애매한 경우 부정확할 수 있음
  - `ETag`는 콘텐츠 자체의 변경 여부를 보장 → 더 정확한 캐싱 가능

---

## 📌 ETag의 종류

- **Strong ETag**: 바이트 단위까지 정확히 동일해야 일치
- **Weak ETag (`W/` 접두사)**: 의미적으로 동등하면 일치로 간주

---

## 📌 Cache-Control과 함께 사용하기

ETag와 Cache-Control은 **보완적인 관계**이며, 함께 사용하면 효과적인 캐싱 전략을 세울 수 있습니다.

- **Cache-Control**: 캐시 정책(유효 기간, 재검증 여부 등)을 직접 지정
- **ETag**: 리소스의 **변경 여부**를 확인하는 메커니즘

### ✅ 예시 1: 정적 리소스

```http
Cache-Control: max-age=31536000
ETag: "abc123"
```

- 이미지, CSS, JS 등 **정적 파일**에 적용
- **1년 동안 캐시 사용**
- 리소스 갱신 시(예: 배포) **ETag 변경 → 새 버전 다운로드**
- (파일명에 **해시 포함 방식**도 흔히 사용됨)

### ✅ 예시 2: 자주 변경되는 API 응답

```http
Cache-Control: no-cache
ETag: "xyz789"
```

- 항상 서버에 **재검증 요청**
- 변경 없음 → `304 Not Modified` 응답
- **데이터 전송량 최소화** 가능
