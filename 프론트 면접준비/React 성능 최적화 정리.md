# React 성능 최적화 정리

> 본 문서는 React 18 기준으로, **렌더링 최소화·코드 전송량 축소·런타임 비용 절감** 관점에서 실무 적용 중심으로 정리했습니다.

---

## 1) 렌더링 최소화

### 1-1. 메모이제이션

- **`React.memo`**: 동일한 props면 컴포넌트 리렌더링을 생략합니다.

  ```jsx
  const Row = React.memo(function Row({ item }) {
    return <div>{item.title}</div>;
  });
  ```

  - 주의: **참조 동등성**이 유지되어야 효과가 있습니다(객체/함수 새 생성 지양). 필요 시 `useMemo`/`useCallback`으로 안정화합니다.

- **`useCallback` / `useMemo`**: 함수/값의 재생성·재계산 방지.
  ```jsx
  const onSelect = useCallback((id) => setSel(id), [setSel]);
  const total = useMemo(() => items.reduce((a, b) => a + b.price, 0), [items]);
  ```
  - 과도한 사용은 복잡도만 증가할 수 있으니 **핫스팟** 위주로 적용하십시오.

### 1-2. 상태 관리 전략

- **State Colocation**: 상태는 **필요한 가장 가까운 곳**에 두어 **불필요한 상위/형제 리렌더**를 줄입니다.
- **불필요한 파생 상태 금지**: 계산으로 얻을 수 있는 값은 **저장하지 말고 계산**하십시오.
- **컨텍스트 분리/선택자 패턴**: 컨텍스트 값 변경은 **구독 컴포넌트 전체**를 리렌더합니다.
  - 값 덩어리를 쪼개거나, **selector 기반 컨텍스트**(분리 Provider), 외부 스토어는 `useSyncExternalStore`를 활용하십시오.

### 1-3. 리스트와 키

- **가상 스크롤(윈도우링)**: 긴 목록은 `react-window`, `react-virtualized` 등으로 **화면 내 항목만** 렌더하십시오.
- **안정 키 사용**: `index` 키 남용은 재정렬 시 **불필요 리렌더**와 상태 꼬임의 원인입니다.

### 1-4. 불필요한 리렌더 파악

- **React Profiler**로 커밋 타임라인과 리렌더 원인을 파악하십시오.
- DevTools의 **Highlight updates** 옵션으로 변하는 컴포넌트를 시각화하십시오.

---

## 2) 코드 전송량 및 초기 로드 최적화

### 2-1. 코드 스플리팅

- **언제 사용하는가**
  1. **초기 로딩 시간이 길 때**: 핵심 경로만 먼저 로드, 나머지는 **지연 로드**합니다.
  2. **라우트별 분할**: 페이지 단위 청크로 분리하여 **접속 경로별** 필요한 코드만 받도록 합니다.
  3. **희소 기능/무거운 의존성**: 차트·에디터·맵·미디어 처리와 같은 **대형 라이브러리**를 사용 시에 효과가 큽니다.
- **기본 패턴**
  ```jsx
  const Settings = React.lazy(() => import("./pages/Settings"));
  function App() {
    return (
      <Suspense fallback={<Spinner />}>
        <Settings />
      </Suspense>
    );
  }
  ```
- **라우트 기반**: 라우터에서 `lazy()` 또는 동적 import로 경로별 청크를 생성하십시오.
- **사전 프리로드**: 사용자 행동을 예측할 수 있으면 `link rel="prefetch"`/`preload` 또는 라우터의 **preload API**로 체감 속도를 높이십시오.

### 2-2. 번들 최적화

- **트리 셰이킹/ESM**: 사용 부분만 임포트(예: `import { add } from 'lodash-es'`). CommonJS 의존성은 교체 검토.
- **중복 제거**: 아이콘/유틸은 **선택 임포트**. 날짜/국제화 라이브러리는 경량 대안 고려.
- **압축/전송**: Gzip/Brotli, HTTP/2 이상, 캐시 헤더, immutable 파일명(`contenthash`)을 적용하십시오.
- **이미지/폰트**: WebP/AVIF, 서브셋 폰트, 폰트 디스플레이(`swap`), 적절한 `sizes/srcset`을 설정하십시오.

---

## 3) 동시성·스케줄링 활용(React 18)

- **`useTransition`**: 상태 업데이트를 **긴급/비긴급**으로 분리하여 입력 체감(typing) 품질을 높입니다.
  ```jsx
  const [isPending, startTransition] = useTransition();
  const onFilter = (v) => startTransition(() => setQuery(v));
  ```
- **`useDeferredValue`**: 무거운 파생 연산을 **지연된 값**으로 연결하여 프레임 드롭을 줄입니다.
- **`Suspense`**: 데이터/코드 로딩 중 UI 분할을 통해 **점진적 렌더링**을 구현합니다.
- **서버 컴포넌트(RSC)** 도입 가능 시, **서버에서 렌더링/데이터 패칭/중량 의존성**을 처리하여 클라이언트 번들을 줄일 수 있습니다.

---

## 4) 데이터 패칭·캐싱

- **서버 상태는 별도 관리**: TanStack Query 등으로 **캐싱/동기화/재검증**을 맡겨 **리렌더와 네트워크 낭비**를 줄입니다.
  - `staleTime`, `gcTime`, `select`, `keepPreviousData` 등으로 **리스트/디테일 전환**의 깜박임을 줄이십시오.
- **메모이즈드 선택자**: 클라이언트 상태 라이브러리(Redux 등)에서는 **메모이즈드 셀렉터**로 계산 비용을 상쇄합니다.

---

## 5) 브라우저 렌더링 비용 절감

- **레이아웃 스래싱 방지**: 읽기(`getBoundingClientRect`)와 쓰기(`style.*`)를 **분리·배치**하십시오.
- **컴포지트 전용 애니메이션**: `transform`/`opacity` 위주로 설계, 필요 시 `will-change`를 제한적으로 사용하십시오.
- **비용 큰 스타일**: 큰 `box-shadow`/`filter: blur()`/복잡한 배경은 **페인트 비용**을 늘립니다.
- **가상화/오프스크린**: `content-visibility: auto`, 인터섹션 옵저버로 **보이는 영역만** 작업하십시오.

---

## 6) 안티패턴과 주의사항

- `memo`/`useMemo`/`useCallback` **남용 금지**: 의존성 관리 비용이 더 클 수 있습니다.
- **상태를 상위에 과도히 배치**하지 마십시오. 작은 변경이 **광범위 리렌더**를 유발합니다.
- **컨텍스트에 함수/대형 객체**를 그대로 넣지 마십시오. Provider 값 변경 시 **모두 리렌더**됩니다.
- **무거운 계산을 렌더 단계에서 수행**하지 마십시오. Web Worker/지연 계산/메모화를 고려하십시오.
- **이미지 과대 전송**: 해상도/포맷 미스매치가 LCP를 악화시킵니다.

---

## 7) 체크리스트

- [ ] 병목 컴포넌트를 **Profiler**로 식별했다.
- [ ] 상태는 **콜로케이션**하고, 파생 값은 **저장하지 않는다**.
- [ ] 리스트는 **가상 스크롤**/안정 키 사용.
- [ ] **React.memo + useCallback/useMemo**를 **핫스팟**에만 적용.
- [ ] **코드 스플리팅**과 **프리로딩**으로 초기 경로 최적화.
- [ ] **서버 상태 라이브러리**를 사용해 패칭/캐싱을 표준화.
- [ ] **컴포지트 전용 애니메이션**으로 렌더링 비용을 통제.
- [ ] 번들/이미지/폰트 **전송 최적화** 적용.

---

## 8) 코드 스플리팅 추가 해설

- **적용 대상**
  - 초기 접근 경로에 필요하지 않은 **대형 의존성**(차트·리치 에디터·지도·미디어 처리).
  - **관리 페이지/희소 기능**처럼 사용 빈도가 낮은 화면.
  - **라우트 전환 시점**에 로드해도 사용자 체감이 낮은 UI.
- **주의 사항**
  - **폴백 UI**(스피너·스켈레톤)를 제공하여 지연 로드를 사용자에게 자연스럽게 전달하십시오.
  - **중첩 Suspense 경계**로 화면 일부만 로딩 상태를 표시하십시오.
  - **프리페치 전략**으로 사용자가 접근하기 직전 미리 받아 두면 체감 속도가 개선됩니다.

---

## 9) 요약

- 핵심은 **불필요한 리렌더 감소**, **필요한 코드만 전송**, **브라우저 작업 최소화**입니다.
- `React.memo / useMemo / useCallback`은 **핫스팟을 정밀 겨냥**해 사용하시고, 구조적 개선(상태 배치·가상 스크롤·코드 스플리팅·데이터 캐싱)을 병행하는 것이 가장 효과적입니다.
