# 리액트 컴포넌트 정리

## 1) 정의

- **컴포넌트(Component)**: UI를 구성하는 **독립적이고 재사용 가능한** 코드 단위.
- **캡슐화**된 뷰/로직을 가지며, 입력(**props**)을 받아 출력(JSX)을 생성.
- **단일 책임** 원칙을 지향: 한 가지 역할에 집중하도록 설계.

---

## 2) 종류

### 함수형 컴포넌트(권장)

- Hooks(`useState`, `useEffect`, `useMemo`, `useCallback` 등)로 상태/사이드이펙트 관리.
- 선언적이고 간결. 최근 리액트 생태계의 **표준**.

```tsx
function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}
```

### 클래스형 컴포넌트(레거시/유지보수용)

- `this.state`, 라이프사이클 메서드(`componentDidMount` 등) 사용.
- 신규 개발보다는 기존 코드 유지에 주로 사용.

---

## 3) 데이터 모델

- **Props**: 부모 → 자식 **단방향 데이터 흐름**. 읽기 전용(자식에서 변경 금지).
- **State**: 컴포넌트 내부에서 관리하는 가변 데이터. 상태 변경 시 리렌더링.

```tsx
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount((c) => c + 1)}>{count}</button>;
}
```

---

## 4) 설계 원칙 & 모범 사례

1. **단일 책임**: UI 파트/기능 파트를 잘게 나눠 결합도를 낮춤.
2. **관심사 분리**: 비즈니스 로직과 뷰 로직 분리(예: 컨테이너/프레젠테이셔널).
3. **재사용성**: 변하는 것만 **props로 주입**(데이터, 핸들러, 렌더 프롭, 슬롯 패턴).
4. **컴포지션 우선**: 상속 대신 **합성(Composition)**으로 확장.
5. **상태의 위치**: **상태 끌어올리기(lifting state up)** 또는 상태 라이브러리(Zustand, Redux) 고려.
6. **키 관리**: 리스트 렌더링 시 **안정적이고 고유한 key** 사용(인덱스 지양).
7. **접근성**: 시맨틱 태그, ARIA, 포커스 관리 반영.
8. **에러/경계**: Error Boundary로 UI 안전망 구성(클래스형 또는 에러 경계 유틸).
9. **비동기/데이터**: 서버 상태는 TanStack Query 등으로 관리(캐싱·리트라이·동기화).

---

## 5) 성능 최적화 포인트

- **불필요 리렌더링 억제**
  - `React.memo`로 **props 불변** 시 메모이제이션.
  - `useCallback`/`useMemo`로 **참조 안정성** & **비싼 계산** 캐싱(과용 금지).
- **렌더 비용 분산**
  - 코드 스플리팅(`React.lazy`, `Suspense`), 가상화(리스트), 지연 렌더링.
- **동시성 기능 활용(React 18)**
  - `startTransition`, `useDeferredValue`로 입력/상호작용 우선순위 보장.
- **키/의존성**
  - 불안정한 key, 과도한 의존성 변경이 재렌더 트리거가 되지 않도록 관리.

---

## 6) 자주 쓰는 패턴

- **컨테이너/프레젠테이셔널**: 데이터/상태는 컨테이너, 화면은 프레젠테이셔널.
- **Controlled vs Uncontrolled**: 폼 제어 수준과 비용에 따라 선택.
- **Render Props / Slot 패턴**: 유연한 확장성 제공.
- **Compound Components**: 관련 컴포넌트들을 한 API로 묶어 조합.

```tsx
// Compound 예시
const Tabs = ({ children }) => <div>{children}</div>;
Tabs.List = ({ children }) => <div role="tablist">{children}</div>;
Tabs.Panel = ({ children }) => <div role="tabpanel">{children}</div>;
```

---

## 7) 안티 패턴

- 거대한 “만능” 컴포넌트(책임 과다).
- **인덱스 key** 사용으로 상태/DOM 재활용 오류.
- 하위 트리에 불필요한 **컨텍스트 남발**.
- `useEffect`를 **데이터 파이프라인 전용**으로 남용(가능하면 이벤트/계산으로 대체).
- 메모이제이션 과용으로 오히려 비용 증가.

---

## 8) 체크리스트

- 이 컴포넌트의 **책임은 하나**인가?
- **입력(props)** 과 **출력(JSX)** 이 명확한가?
- 상태의 **소유 위치**가 적절한가? 서버/클라이언트 상태 분리했는가?
- **키/의존성/메모이제이션**이 적절한가?
- 접근성, 에러 경계, 로딩/에ンプ티/에러 상태(UI State) 대비했는가?

---

## 9) 미니 예제: 재사용 가능한 버튼

```tsx
type ButtonProps = {
  variant?: "primary" | "ghost";
  onClick?: () => void;
  children: React.ReactNode;
};

const Button = React.memo(function Button({
  variant = "primary",
  onClick,
  children,
}: ButtonProps) {
  const className = variant === "primary" ? "btn btn-primary" : "btn btn-ghost";
  return (
    <button className={className} onClick={onClick}>
      {children}
    </button>
  );
});
```

- **역할 분리**: 스타일은 `variant`, 동작은 `onClick`, 콘텐츠는 `children`으로 주입.
- **메모이제이션**: 동일 props면 재렌더 방지.
- **확장 용이**: 아이콘 슬롯, 로딩 상태, 접근성 속성 등 확장.

---

## 10) 한줄 정리

> 컴포넌트는 “한 책임을 가진, 합성으로 확장되는, 데이터는 위에서 아래로 흐르는 재사용 가능한 UI 단위”입니다.
