
# 함수 선언식 vs 함수 표현식 정리

> 핵심 요약: **함수 선언식(function declaration)** 은 전체가 호이스팅되어 **선언 이전 호출이 가능**합니다. **함수 표현식(function expression)** 은 변수에 함수를 담는 방식으로, 변수의 스코프/호이스팅 규칙을 따르므로 **할당 이후에만 호출**할 수 있습니다.

---

## 1) 정의 방식과 문법

### 함수 선언식
```js
function add(a, b) {
  return a + b;
}
```

### 함수 표현식
```js
// 익명 함수 표현식
const multiply = function (a, b) {
  return a * b;
};

// 이름 있는 함수 표현식(디버깅/재귀에 유리)
const factorial = function fact(n) {
  return n <= 1 ? 1 : n * fact(n - 1);
};

// 화살표 함수(함수 표현식의 축약 문법)
const minus = (a, b) => a - b;
```

---

## 2) 호이스팅(가장 큰 차이)

### 선언식은 **함수 본문까지** 호이스팅
- 실행 전에 함수 식별자와 **함수 구현 전체가 메모리에 로드**됩니다.
- 따라서 **선언 위치보다 먼저 호출 가능**합니다.

```js
console.log(add(2, 3)); // 5

function add(a, b) {
  return a + b;
}
```

### 표현식은 **변수의 호이스팅 규칙**을 따름
- `var`는 선언만 호이스팅(초기값 `undefined`) → **할당 전 호출 시 TypeError**
- `let/const`는 **TDZ(Temporal Dead Zone)** 에 의해 **선언 이전 접근 불가**

```js
// let/const: TDZ로 ReferenceError
console.log(multiply);     // ReferenceError
const multiply = (a, b) => a * b;

// var: 선언은 호이스팅되지만 값은 undefined → 호출하면 TypeError
console.log(divide);       // undefined
// divide(6, 3);           // TypeError: divide is not a function
var divide = function (a, b) { return a / b; };
```

---

## 3) 스코프 · this · 사용성 차이(관련 포인트)

- **스코프**: 둘 다 어휘적 스코프(렉시컬 스코프)를 따릅니다.
- **this 바인딩**: 선언식/일반 표현식은 호출 방식에 따라 `this`가 달라집니다. 화살표 함수는 **자체 this가 없고** 상위 스코프의 `this`를 캡처합니다(주로 콜백에서 편리).
- **이름 있는 함수 표현식**은 스택 트레이스 가독성/재귀 구현에 유리합니다.
- **재선언**: 동일 스코프에서 함수 선언을 중복하면 의도치 않은 **오버라이드**가 될 수 있으므로 모듈/블록 스코프에서 주의합니다.

---

## 4) 언제 무엇을 쓸까?

- **전역/모듈 최상단의 유틸 함수**처럼 어디서든 바로 사용할 기본 동작이라면 → **함수 선언식**
- **조건부 정의, 클로저에 의존, 의존성 주입, 콜백 전달** 등 값처럼 다루어야 한다면 → **함수 표현식**
- **this가 필요 없고 간결함**이 중요한 콜백 → **화살표 함수(표현식)**

> 팀 규칙: 재현 가능한 초기화 순서를 보장하려면 **선언 시점 아래에서만 호출**하도록 린팅(예: `eslint no-use-before-define`)을 사용하기도 합니다.

---

## 5) 자주 하는 실수와 베스트 프랙티스

- `let/const` 변수에 담긴 함수는 **할당 이후에만 호출**(TDZ 주의).
- `var` + 함수 표현식은 **호이스팅 오해**로 인한 런타임 오류를 유발할 수 있으므로 지양.
- 디버깅 편의가 필요하면 **이름 있는 함수 표현식** 사용.
- 일관성을 위해 **모듈 범위에서는 선언식**, 내부 콜백/클로저에서는 **표현식(화살표)** 를 섞어 사용하는 패턴이 실무에서 흔함.

---

## 6) 비교 표

| 구분 | 함수 선언식 | 함수 표현식 |
|---|---|---|
| 문법 | `function foo(){}` | `const foo = function(){}` / `const foo = () => {}` |
| 호이스팅 | **함수 본문까지** 호이스팅 → 선언 이전 호출 가능 | 변수 규칙 따름: `let/const`는 TDZ, `var`는 `undefined` |
| this | 일반 함수 규칙(호출 방식에 의존) | 일반/화살표에 따라 다름(화살표는 상위 this 캡처) |
| 용도 | 모듈/전역 유틸, 기본 동작 | 콜백, 조건부/동적 정의, 클로저 의존 로직 |
| 디버깅 | 이름 고정, 스택에 잘 표시 | 이름 있는 표현식이면 스택 가독성 ↑ |

---

## 7) 결론
- **호이스팅 관점**: 선언식은 안전하게 먼저 호출 가능, 표현식은 **할당 이후**만 가능
- **설계 관점**: “어디서든 바로 쓰는 **고정 API**”는 선언식, “값으로 다뤄지는 **동적/콜백 로직**”은 표현식이 적합
