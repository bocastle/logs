# 함수형 프로그래밍을 해야 하는 이유

함수형 프로그래밍은 단순한 트렌드가 아니라 **현대 소프트웨어 개발의 필수 요소**가 되었습니다. 특히 프론트엔드 개발에서 함수형 프로그래밍의 중요성은 더욱 커지고 있습니다.

---

## 1. 현대 JavaScript 생태계의 변화

### ES6+ 도입으로 인한 패러다임 전환

```javascript
// 기존 명령형 방식
const numbers = [1, 2, 3, 4, 5];
const doubled = [];
for (let i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2);
}

// 함수형 방식
const doubled = numbers.map((n) => n * 2);
```

**React, Vue, Angular 등 현대 프레임워크들이 함수형 프로그래밍을 기반으로 설계**되었기 때문에, 함수형 사고가 없으면 프레임워크의 장점을 제대로 활용할 수 없습니다.

---

## 2. React 생태계에서의 필수성

### 함수형 컴포넌트의 대두

```javascript
// 클래스 컴포넌트 (구식)
class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = { user: null };
  }

  componentDidMount() {
    // 복잡한 생명주기 관리
  }

  render() {
    return <div>{this.state.user?.name}</div>;
  }
}

// 함수형 컴포넌트 (현대적)
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // 간단하고 직관적인 상태 관리
  }, [userId]);

  return <div>{user?.name}</div>;
};
```

**React Hooks는 함수형 프로그래밍의 핵심 개념들을 기반으로 설계**되었습니다:

- `useState`: 불변성을 통한 상태 관리
- `useEffect`: 순수 함수와 부수 효과의 분리
- `useCallback`, `useMemo`: 메모이제이션을 통한 최적화

---

## 3. 코드 품질 향상

### 버그 발생 가능성 감소

```javascript
// 명령형 방식 - 버그 발생 가능성 높음
let total = 0;
for (let i = 0; i < items.length; i++) {
  if (items[i].price > 100) {
    total += items[i].price; // 실수로 total = items[i].price로 작성할 수 있음
  }
}

// 함수형 방식 - 실수할 여지가 적음
const total = items
  .filter((item) => item.price > 100)
  .reduce((sum, item) => sum + item.price, 0);
```

### 테스트 용이성

```javascript
// 순수 함수는 테스트하기 쉬움
const calculateDiscount = (price, discountRate) => {
  return price * (1 - discountRate);
};

// 테스트 코드
test("calculateDiscount should return correct discounted price", () => {
  expect(calculateDiscount(100, 0.2)).toBe(80);
  expect(calculateDiscount(200, 0.1)).toBe(180);
});
```

---

## 4. 성능 최적화

### 메모이제이션과 최적화

```javascript
// React에서의 메모이제이션
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => {
    return data.map((item) => ({
      ...item,
      processed: heavyComputation(item),
    }));
  }, [data]);

  return <div>{/* 렌더링 로직 */}</div>;
});
```

**함수형 프로그래밍의 불변성과 순수성은 React의 렌더링 최적화와 완벽하게 맞아떨어집니다.**

---

## 5. 팀 협업과 코드 유지보수

### 코드 가독성 향상

```javascript
// 명령형 방식 - 의도 파악이 어려움
function processUsers(users) {
  const result = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].age >= 18 && users[i].isActive) {
      const processed = {
        name: users[i].name.toUpperCase(),
        age: users[i].age,
        status: "adult",
      };
      result.push(processed);
    }
  }
  return result;
}

// 함수형 방식 - 의도가 명확함
const processUsers = (users) =>
  users
    .filter((user) => user.age >= 18 && user.isActive)
    .map((user) => ({
      name: user.name.toUpperCase(),
      age: user.age,
      status: "adult",
    }));
```

### 디버깅 용이성

각 단계가 명확하게 분리되어 있어 문제 발생 시 해당 단계만 확인하면 됩니다.

---

## 6. 미래 지향적 개발

### TypeScript와의 시너지

```typescript
// 함수형 프로그래밍과 타입 시스템의 조화
type User = {
  id: number;
  name: string;
  email: string;
};

const validateUser = (user: User): boolean =>
  user.id > 0 && user.name.length > 0 && user.email.includes("@");

const processUsers = (users: User[]): User[] =>
  users
    .filter(validateUser)
    .map((user) => ({ ...user, name: user.name.trim() }));
```

### 마이크로프론트엔드 아키텍처

함수형 프로그래밍의 모듈성과 조합성은 마이크로프론트엔드 아키텍처에서 큰 장점을 제공합니다.

---

## 7. 실제 면접에서 강조할 포인트

### 기술적 장점

- **성능**: 불변성과 메모이제이션을 통한 최적화
- **안정성**: 부수 효과 최소화로 인한 예측 가능한 동작
- **확장성**: 함수 조합을 통한 유연한 기능 확장

### 비즈니스적 가치

- **개발 속도**: 재사용 가능한 함수 라이브러리 구축
- **팀 생산성**: 명확한 코드 의도로 인한 협업 효율성
- **유지보수 비용**: 버그 발생 가능성 감소

---

## 결론

함수형 프로그래밍은 **"해야 하는" 것이 아니라 "할 수밖에 없는"** 현대 프론트엔드 개발의 필수 요소입니다.

React, Vue 등 현대 프레임워크들이 함수형 프로그래밍을 기반으로 설계되었고, TypeScript, 마이크로프론트엔드 등 새로운 기술 트렌드와도 완벽하게 호환됩니다.

**함수형 프로그래밍을 모르면 현대 프론트엔드 개발의 50% 이상을 놓치고 있다고 해도 과언이 아닙니다.**
