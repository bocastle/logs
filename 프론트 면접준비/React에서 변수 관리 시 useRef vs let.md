# React에서 변수 관리 시 `useRef` vs `let`

React 컴포넌트에서 변수를 관리할 때 `useRef()`와 `let`의 차이를 이해하는 것은 상태 관리의 안정성과 예측 가능성을 높이는 데 중요합니다.

---

## ✅ 1. **리렌더링 시 동작 차이**

| 구분                  | 리렌더링 시 값 유지 여부 | 값 변경 시 리렌더링 유발 여부 |
| --------------------- | ------------------------ | ----------------------------- |
| `let` (컴포넌트 내부) | ❌ 초기화됨              | ❌                            |
| `useRef()`            | ✅ 값 유지됨             | ❌                            |
| `useState()`          | ✅ 값 유지됨             | ✅                            |

- **`let`**: 컴포넌트 함수가 다시 호출될 때마다 **새로 초기화** → 이전 값 소실
- **`useRef`**: 컴포넌트가 리렌더링되어도 **값 유지**
- **`useState`**: 값 유지 + 값 변경 시 리렌더링 발생

---

## ✅ 2. **`useRef()`의 주요 특징**

1. **DOM 접근**

   ```jsx
   const inputRef = useRef(null);

   useEffect(() => {
     inputRef.current.focus();
   }, []);

   return <input ref={inputRef} />;
   ```

   - 특정 DOM 요소에 직접 접근 가능 (e.g., focus, scroll)

2. **리렌더링 간 값 유지 (비상태)**

   ```jsx
   const timerId = useRef(null);

   useEffect(() => {
     timerId.current = setTimeout(() => {
       console.log("타이머 종료");
     }, 1000);

     return () => clearTimeout(timerId.current);
   }, []);
   ```

   - `setTimeout` / `setInterval`의 ID 저장 등에 활용
   - 값이 변해도 컴포넌트가 리렌더링되지 않음

---

## ✅ 3. **그렇다면 컴포넌트 외부에 `let`을 쓰면?**

- **사실**: 컴포넌트 외부의 `let` 변수는 리렌더링의 영향을 받지 않음
- **하지만 권장 ❌**
  - **모든 인스턴스가 변수를 공유** → 여러 개의 같은 컴포넌트를 동시에 렌더링할 때 **예상치 못한 동작**
  - 전역 변수처럼 동작 → 예측 가능성과 유지보수성 저하
  - React의 **단방향 데이터 흐름** 원칙 위배

---

## 🧠 결론

| 상황                                     | 추천 방법                           |
| ---------------------------------------- | ----------------------------------- |
| 렌더링에 영향 주는 값                    | `useState()`                        |
| 렌더링에 영향 안 주지만 값 유지 필요     | `useRef()`                          |
| 단순히 한 함수 내에서만 사용하는 임시 값 | `let` (단, 컴포넌트 외부 사용 지양) |

> 💡 **규칙**: 값이 UI에 반영되어야 한다면 `useState`, 값이 유지되어야 하지만 렌더링에 영향 없으면 `useRef`.
