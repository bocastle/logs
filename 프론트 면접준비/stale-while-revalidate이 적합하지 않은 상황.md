# stale-while-revalidate이 적합하지 않은 상황

## 문제

`stale-while-revalidate`는 사용자 경험을 개선하는 강력한 캐싱 전략이지만, **모든 상황에 적합하지는 않습니다**.  
특히 **실시간성이 매우 중요한 서비스**에서는 오래된 데이터를 잠시라도 보여주는 것이 심각한 문제로 이어질 수 있습니다.

---

## 특징

- **장점**: 사용자에게 빠른 응답 제공 (캐시 먼저), 백그라운드에서 최신 데이터로 갱신.
- **단점**: 일정 시간 동안 사용자가 **구식 데이터**를 보게 됨.

---

## 적합하지 않은 상황

### 1. 실시간성이 핵심인 서비스

- **주식/환율 시세**: 몇 초 차이로도 금전적 손실 가능.
- **실시간 재고/예약 현황**: 오래된 정보로 인해 결제 오류, 초과 예약, 이중 예약 발생 가능.
- **스포츠 경기 라이브 스코어**: 수 초라도 차이나면 사용자의 신뢰 상실.

---

### 2. 정확성이 최우선인 서비스

- **결제 금액/환불 내역**: 캐시된 금액이 잘못 표시되면 민원 및 법적 문제로 확대.
- **의료 데이터/검사 결과**: 환자에게 잘못된 정보 제공 → 치명적 결과.
- **법률/계약 문서**: 오래된 데이터를 보여줄 경우 법적 책임 발생 가능.

---

### 3. 빈번하게 변동되는 데이터

- 데이터 변경 주기가 짧아 `stale-while-revalidate` 윈도우가 사실상 의미 없음.
- 캐시된 데이터가 실제 데이터와 불일치할 확률이 높음.

---

## 최적화 전략

- **실시간성이 필요한 경우**: `stale-while-revalidate` 대신 `no-cache` 또는 `must-revalidate` 사용.
- **데이터 중요도에 따라 혼합 전략** 적용:
  - 중요 데이터(API): 즉시 최신화 (`max-age=0, must-revalidate`)
  - 보조 데이터(추천 목록, UI 리소스): `stale-while-revalidate` 적용

---

## 결론

`stale-while-revalidate`는 **UX 최적화**에 유용하지만,

- **실시간성**
- **정확성**
- **법적/금전적 민감도**

이 세 가지 요인이 중요한 서비스에서는 적합하지 않습니다.

👉 따라서, **데이터의 성격에 따라 캐싱 전략을 분리**하는 것이 가장 안전한 접근입니다.
