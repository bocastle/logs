# 자바스크립트 이벤트 루프 정리

> 본 문서는 브라우저 환경 중심으로 설명하며, 말미에 Node.js 특이점도 간략히 다룹니다.

## 한눈에 보기

| 구성요소            | 의미                                                   | 예시                                  |
| ------------------- | ------------------------------------------------------ | ------------------------------------- |
| **Call Stack**      | 현재 실행 중인 함수 프레임이 쌓이는 스택               | 동기 함수 호출/반환                   |
| **Web APIs / Host** | 타이머, DOM, 네트워크 등 런타임이 제공하는 비동기 기능 | `setTimeout`, `fetch`, DOM 이벤트     |
| **Task Queues**     | 완료된 비동기 작업의 콜백이 대기하는 큐                | **매크로태스크**와 **마이크로태스크** |
| **Event Loop**      | 스택과 큐를 조정하여 콜백을 실행                       | 스택이 비면 큐에서 작업을 가져와 실행 |

---

## 기본 동작 흐름

1. **동기 코드**는 Call Stack에서 즉시 실행됩니다.
2. **비동기 API 호출**(예: `setTimeout`, `fetch`)은 Host가 맡아 처리하고, 조건이 충족되면 해당 콜백을 **적절한 큐**에 넣습니다.
3. **Event Loop**는 Stack이 비었을 때, 우선 **마이크로태스크 큐**를 **모두 비울 때까지** 처리한 뒤, 필요 시 **렌더링 기회**를 주고, 다음으로 **매크로태스크 큐**에서 **작업 하나**를 가져와 실행합니다.
4. 이 사이클을 반복합니다.

> `setTimeout(fn, 0)`이라도 동기 작업이 끝나고, 마이크로태스크가 모두 처리된 후에야 실행됩니다. “다음 틱으로 미룬다”는 의미입니다.

---

## 태스크 큐의 종류

### 마이크로태스크(Microtasks) — **더 높은 우선순위**

- **주요 소스**:
  - `Promise`의 `then/catch/finally` 반응(Reaction)
  - `queueMicrotask`
  - `MutationObserver`
- **특징**:
  - 이벤트 루프는 **스택이 비는 시점마다 마이크로태스크를 전부 처리**합니다(드레인).
  - 과도한 마이크로태스크 생성은 **렌더링 지연**을 유발할 수 있습니다(스타베이션).

### 매크로태스크(Macrotasks)

- **주요 소스**:
  - `setTimeout`, `setInterval`
  - `MessageChannel`, `postMessage`, 사용자 입력/네트워크 I/O 완료 콜백 등
  - **Node.js**의 `setImmediate`(브라우저에는 없음)
- **특징**:
  - 이벤트 루프는 매크로태스크를 **한 번에 하나씩** 실행합니다.
  - 각 매크로태스크 사이에 **렌더링 기회**가 존재할 수 있습니다.

---

## 렌더링과의 관계

- 브라우저는 보통 **매크로태스크 사이클**과 **마이크로태스크 드레인** 이후에 **렌더링**(레이아웃/페인트)을 수행할 기회를 갖습니다.
- `requestAnimationFrame`(rAF)은 **렌더링 직전**에 콜백을 실행하도록 스케줄됩니다.
- 마이크로태스크가 길게 이어지면 프레임 드롭이 발생할 수 있으므로, 큰 루프는 적절히 **일시 중단(청크)** 하거나 **매크로태스크로 분할**하는 것이 좋습니다.

---

## 실행 순서 예제

### 1) 마이크로태스크가 먼저

```html
<script>
  console.log("A");
  setTimeout(() => console.log("B"), 0); // 매크로태스크
  Promise.resolve().then(() => console.log("C")); // 마이크로태스크
  console.log("D");
</script>
```

**출력 순서**: `A → D → C → B`  
설명: 동기 `A, D` → 마이크로태스크 `C` → 매크로태스크 `B`

### 2) 마이크로태스크 드레인

```js
setTimeout(() => console.log("macro 1"), 0);
Promise.resolve().then(() => {
  console.log("micro 1");
  Promise.resolve().then(() => console.log("micro 2"));
});
```

**출력 순서**: `micro 1 → micro 2 → macro 1`  
설명: 마이크로태스크는 **드레인**(비울 때까지) 처리됩니다.

### 3) rAF와 마이크로태스크

```js
requestAnimationFrame(() => {
  console.log("rAF");
  Promise.resolve().then(() => console.log("micro after rAF"));
});
setTimeout(() => console.log("timeout"), 0);
```

가능한 흐름: `rAF → micro after rAF → timeout`  
설명: 렌더 사이클 직전 rAF → 그 안에서 생긴 마이크로태스크 드레인 → 이후 매크로태스크

---

## async/await과 이벤트 루프

- `await`는 **해당 지점에서 비동기 경로로 분기**시키며, 이어지는 부분은 **마이크로태스크**로 재개됩니다(Promise reaction).
- 따라서 `await` 이후 코드는 **동기 다음, 매크로태스크 이전** 단계에서 실행됩니다.

```js
(async () => {
  console.log("A");
  await null; // 또는 await Promise.resolve()
  console.log("B"); // 마이크로태스크 타이밍
})();
console.log("C"); // 동기
// 출력: A → C → B
```

---

## 성능/안정성 모범 사례

- **긴 작업은 쪼개기**: 대량 계산은 `setTimeout(..., 0)` 또는 `scheduler.postTask`(지원 시)로 분할해 **UI 응답성**을 확보합니다.
- **마이크로태스크 남용 금지**: 무한/과도한 `queueMicrotask`나 `Promise.then` 체인은 렌더링을 막을 수 있습니다.
- **I/O는 스트리밍/청크 처리**: 한 번에 그리지 말고 프레임마다 그리기.
- **rAF를 이용한 애니메이션**: 시간 기반 보정과 함께 rAF에서 DOM 작업을 수행합니다.

---

## Node.js에서의 차이(요약)

- Node.js는 **이벤트 루프 단계**(timers, pending callbacks, poll, check, close callbacks 등)로 구성됩니다.
- **마이크로태스크 종류**:
  - `process.nextTick` 큐(특수, **가장 우선**)
  - `Promise` 마이크로태스크 큐
- 실행 순서 관점에서 `process.nextTick`은 일반 마이크로태스크보다 **더 먼저** 실행되므로, 과도한 사용은 스타베이션을 유발할 수 있습니다.
- 브라우저에 없는 `setImmediate`가 **check 단계**에서 실행됩니다.

---

## 요약

- 자바스크립트는 **싱글 스레드**이지만, 이벤트 루프가 **스택/큐/호스트 환경**을 조정하여 **비동기**를 구현합니다.
- **마이크로태스크**(Promise, queueMicrotask 등)는 **매크로태스크보다 먼저** 전부 처리됩니다.
- `setTimeout(..., 0)`은 **즉시 실행**이 아니라 **다음 틱으로 이연**입니다.
- 렌더링은 보통 **마이크로태스크 드레인 이후**에 기회를 가지며, rAF는 **렌더 직전**에 실행됩니다.
