# 자바스크립트 배열(Array) 정리

---

## 1) 기본 개념

- **순서가 있는 리스트형 객체**로, 인덱스(0 기반)로 요소에 접근합니다.
- **동적 크기**: 미리 길이를 정하지 않아도 되며, 요소 추가/삭제에 따라 `length`가 자동 갱신됩니다.
- **이종 타입 허용**: 숫자, 문자열, 불리언, 객체 등 **서로 다른 타입**을 같은 배열에 담을 수 있습니다.

```js
const array = [1, "apple", true, { key: "value" }];
console.log(array[0], array[3].key); // 1, 'value'
```

---

## 2) 길이(`length`)와 확장

- `length`는 **가장 큰 인덱스 + 1**을 반영합니다.
- **인덱스 할당으로 자동 확장**되며, 중간은 “홀(hole)”(실제 값 없음) 상태가 될 수 있습니다.

```js
const arr = [1, 2, 3];
arr.push(4); // [1, 2, 3, 4]
arr[6] = 7; // [1, 2, 3, 4, <2 empty items>, 7]
console.log(arr.length); // 7
```

> `delete arr[i]`는 요소를 **지우지 않고 hole을 만든다**는 점에 유의하세요. 요소를 당겨 재배치하려면 `splice()`를 사용해야 합니다.

```js
const a = [10, 20, 30];
delete a[1]; // [10, <1 empty item>, 30]; length는 3 유지
a.splice(1, 1); // [10, 30]; length는 2가 됨
```

---

## 3) 내부 동작(엔진 관점 요약)

- 배열은 **객체의 특수한 형태**입니다. 인덱스는 문자열 키로 취급되지만, 엔진은 성능을 위해 **요소 저장 전략**을 바꿉니다.
  - **Dense elements(조밀 배열)**: 작은 정수 인덱스가 연속될 때 빠르게 저장/읽기.
  - **Dictionary/Sparse mode(희소 배열)**: 큰 인덱스 건너뛰기, `delete`/홀 생성 등이 많으면 **해시맵 유사 구조**로 전환되어 성능 저하.
- 따라서 **연속 인덱스**를 유지하고 **홀을 피하는 것**이 일반적으로 유리합니다.

---

## 4) 주요 메서드 분류

### 4-1. **원본을 변경하는 메서드 (mutating)**

- `push`, `pop` (끝에서 추가/삭제) — 평균적으로 빠름
- `shift`, `unshift` (앞에서 추가/삭제) — **모든 요소 이동**이 필요하여 **비쌀 수 있음**
- `splice` (중간 추가/삭제/치환), `sort`, `reverse`, `fill`, `copyWithin`

```js
const xs = [1, 2, 3];
xs.unshift(0); // [0, 1, 2, 3] (앞 삽입: 비용 큼)
xs.splice(1, 2); // [0, 3] (인덱스1부터 2개 삭제)
```

### 4-2. **원본을 변경하지 않는 메서드 (non-mutating)**

- `concat`, `slice`, `map`, `filter`, `reduce`, `flat`, `toSorted`, `toReversed`, `toSpliced`(스펙에 따라 지원)
- **불변 업데이트** 패턴에 적합합니다.

```js
const a = [1, 2, 3];
const b = a.map((x) => x * 2); // a는 그대로, b는 [2, 4, 6]
```

### 4-3. **탐색/검사**

- `find`, `findIndex`, `findLast`, `findLastIndex`, `includes`, `indexOf`, `some`, `every`

### 4-4. **변환/유틸**

- `join`, `flat`, `flatMap`, `from`, `isArray`, `Array.of`

---

## 5) 정렬(`sort`)의 주의점

- 기본 `sort()`는 요소를 문자열로 변환 후 **사전식** 비교합니다. 숫자 정렬은 **비교 함수**를 꼭 전달하세요.
- 현대 엔진은 **안정 정렬(stable)** 을 제공합니다(최신 사양/구현).

```js
[10, 2, 30].sort(); // ["10","2","30"] 기준 → [10, 2, 30] (원치 않을 수 있음)
[10, 2, 30].sort((a, b) => a - b); // [2, 10, 30]
```

---

## 6) 반복(iteration)

- `for`, `for...of`, `forEach`, `map` 등 다양한 방식.
- **홀(hole)** 은 `forEach`/`map`에서 **건너뛰어질 수** 있습니다(엔진/사양에 따라). 일관 동작을 원하면 **희소 배열을 만들지 않는 것**이 안전합니다.

```js
const x = [1, , 3]; // hole 포함
x.map((v) => v ?? 0); // [1, , 3] → 일부 콜백이 호출되지 않을 수 있음
```

---

## 7) 얕은 복사/비교와 구조 분해

- 배열은 **참조 타입**입니다. `===` 비교는 **참조 동일성**을 비교합니다.
- 복사에는 **스프레드**나 `slice`/`concat`을 사용하세요(얕은 복사).

```js
const arr1 = [1, 2];
const arr2 = arr1; // 같은 참조
const arr3 = [...arr1]; // 얕은 복사(별개 참조)
console.log(arr1 === arr2); // true
console.log(arr1 === arr3); // false

const [first, ...rest] = [1, 2, 3]; // 구조 분해
```

---

## 8) 희소 배열과 성능 팁

- **희소(Sparse) 배열**(큰 인덱스 건너뛴 할당, `delete`, 빈 슬롯)은
  - 반복 동작이 비예측적이며,
  - 엔진이 **사전(해시) 형태**로 전환하여 **성능이 저하**될 수 있습니다.
- 팁
  - 요소 삭제엔 `splice()` 사용(홀 방지).
  - 필요한 경우 **길이 미리 확보** 후 연속적으로 채우기(`new Array(n).fill(0)` 등).
  - 대규모 수치 연산은 **TypedArray** 고려(아래 참고).

---

## 9) 고성능 숫자 배열: TypedArray / ArrayBuffer

- `Float32Array`, `Int32Array` 등 **고정 길이, 단일 타입, 연속 메모리** 배열.
- **바운드 체크/엔디언** 등 제약이 있으나, **연산/전송**에서 일반 배열보다 효율적입니다.
- 바이너리 데이터는 `ArrayBuffer`/`DataView`와 함께 다룹니다.

```js
const buf = new ArrayBuffer(16);
const view = new Int32Array(buf);
view[0] = 42;
```

---

## 10) 흔한 실수와 모범 사례

**실수**

- `delete arr[i]`로 요소 제거(→ hole 생성)
- 숫자 정렬에서 비교 함수 생략
- 대형 리스트 앞쪽 삽입/삭제(`shift`/`unshift`) 남용
- 희소 배열에 `forEach`/`map` 가정

**모범 사례**

- 제거는 `splice`, 불변 업데이트는 `slice`/스프레드/`toSpliced`
- 숫자 정렬 시 `(a,b)=>a-b`
- 앞쪽 작업은 **Deque 구조**(예: LinkedList 유사 라이브러리) 또는 **끝 방향 연산**으로 모델링
- 대규모 수치/이진 데이터는 **TypedArray**로

---

## 11) 체크리스트

- [ ] 불변 업데이트가 필요한가? → `slice`/스프레드/`to*` 시리즈 활용
- [ ] 요소 제거에 `delete`를 쓰고 있지 않은가? → `splice`
- [ ] 희소 배열/홀을 만들고 있지 않은가?
- [ ] 숫자 정렬에 비교 함수를 전달했는가?
- [ ] 대용량/수치 연산이면 TypedArray가 적합한가?

---

## 12) 요약

- 자바스크립트 배열은 **동적 크기, 이종 타입**을 지원하는 **객체 기반** 구조입니다.
- 엔진은 **조밀한 배열**에 최적화되어 있으므로 **연속 인덱스·hole 회피**가 성능에 유리합니다.
- 메서드의 **변경 여부**를 구분하고, **정렬/삭제/반복**의 함정을 피하면 신뢰성과 성능을 동시에 확보할 수 있습니다.
