# 프로토타입 상속 동작 방식 정리

자바스크립트의 “상속”은 클래스 기반 언어처럼 **복사(copy)**로 이루어지는 것이 아니라, 객체가 다른 객체를 **참조(reference)** 하도록 연결하는 **프로토타입 체인(Prototype Chain)** 기반으로 동작합니다.

---

## 1) 핵심 개념

### 1-1. `[[Prototype]]` (내부 슬롯)

- 모든 객체는 내부적으로 `[[Prototype]]`이라는 숨김 참조를 가집니다.
- `[[Prototype]]`은 **다른 객체(프로토타입 객체)** 또는 `null`을 가리킵니다.
- 개발자가 직접 `[[Prototype]]`에 접근할 수는 없고, 보통 아래 API로 간접 접근합니다.
  - `Object.getPrototypeOf(obj)` : 프로토타입 조회
  - `Object.setPrototypeOf(obj, proto)` : 프로토타입 설정(성능상 지양)
  - (레거시) `obj.__proto__` : 비표준처럼 쓰였으나 현재는 “웹 호환” 목적으로 남아있는 접근자

### 1-2. 함수의 `prototype` 프로퍼티

- **함수(생성자 함수)** 는 `prototype` 프로퍼티를 가질 수 있습니다.
- `new Foo()`로 생성된 인스턴스의 `[[Prototype]]`은 기본적으로 `Foo.prototype`을 가리키도록 설정됩니다.

> 정리:
>
> - `obj.[[Prototype]]` : “obj가 상속받는 대상(부모)”
> - `Ctor.prototype` : “Ctor로 만들어진 인스턴스들이 공유하는 메서드/프로퍼티가 담기는 객체”

---

## 2) 프로퍼티 탐색: 프로토타입 체인 룩업

객체에서 프로퍼티/메서드를 읽을 때 엔진은 아래 순서로 탐색합니다.

1. **자기 자신(own properties)** 에서 찾는다.
2. 없으면 `[[Prototype]]`이 가리키는 객체(부모)에서 찾는다.
3. 또 없으면 그 부모의 `[[Prototype]]`으로 계속 올라간다.
4. 최종적으로 `null`에 도달하면 탐색 실패(`undefined`).

이를 **프로토타입 체인(Prototype Chain)** 이라고 부릅니다.

---

## 3) “가려짐(Shadowing)”과 “수정(Write)”

### 3-1. 가려짐(Shadowing)

- 부모 프로토타입에 같은 이름의 프로퍼티가 있어도, 자식(인스턴스)에 동일한 이름의 프로퍼티를 만들면 **자식이 우선**입니다.
- 즉, 부모의 프로퍼티는 “사라진 것”이 아니라 “가려진 것”입니다.

### 3-2. 쓰기(할당)의 기본 규칙

- `obj.x = 10` 처럼 **할당**하면, 기본적으로 `obj`에 **자기 자신 프로퍼티(own property)** 가 만들어집니다.
- 그래서 “부모의 x를 바꾸는 것”처럼 보이더라도 실제로는 자식에 새로 만들어져 **shadowing**되는 경우가 많습니다.

> 예외: 부모에 `setter`가 있거나, `writable: false` / `accessor property` 등이면 동작이 달라질 수 있습니다.

---

## 4) 생성자 함수 / `Object.create()` 방식 비교

### 4-1. `Object.create(proto)`

- 특정 프로토타입을 **명시적으로 지정**하여 객체를 만듭니다.

```js
const dog = {
  greet() {
    console.log("Hello from dog!");
  },
};

const maru = Object.create(dog); // maru.[[Prototype]] === dog
maru.greet(); // dog.greet를 찾아 실행
```

### 4-2. 생성자 함수의 `prototype` + `new`

- 생성자 함수의 `prototype`을 통해 “인스턴스가 공유할 동작”을 정의합니다.

```js
function Dog() {}
Dog.prototype.greet = function () {
  console.log("Hello from Dog!");
};

const maru = new Dog(); // maru.[[Prototype]] === Dog.prototype
maru.greet();
```

---

## 5) 왜 이렇게 설계되었나 (실무 관점 포인트)

- **메서드 공유**: 인스턴스마다 함수를 복사하지 않고, 프로토타입에 두어 메모리를 절약합니다.
- **동적 확장**: 런타임에 프로토타입에 메서드를 추가하면, 연결된 인스턴스들이 즉시 영향을 받습니다.
- **주의점(성능/예측가능성)**:
  - `Object.setPrototypeOf`(또는 `__proto__`)로 프로토타입을 자주 바꾸면 최적화가 깨져 성능이 떨어질 수 있습니다.
  - 상속 체인이 너무 깊으면 룩업 비용이 늘 수 있습니다.
  - “쓰기(할당)가 부모를 바꾼다”는 오해로 버그가 생기기 쉽습니다(대부분 shadowing).

---

## 6) 한 문장 요약

**프로토타입 상속은 객체가 다른 객체를 `[[Prototype]]`으로 참조하여, 프로퍼티를 찾을 때 체인을 따라 올라가며 룩업하는 방식**입니다.
