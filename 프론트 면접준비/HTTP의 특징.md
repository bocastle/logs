# HTTP/2의 특징 (프론트엔드 관점)

## 문제

HTTP/1.1은 웹이 발전하면서 **성능 한계**에 직면했다.  
특히 요청과 응답의 순차 처리 방식 때문에 페이지 로딩 속도가 느려지고, 헤더 중복으로 네트워크 자원 낭비가 발생했다.  
이를 해결하기 위해 등장한 프로토콜이 **HTTP/2 (HTTP 2.0)**이다.

## 주요 특징

### 1. Multiplexing

- 하나의 TCP 연결에서 여러 요청과 응답을 **동시에 독립적 스트림**으로 처리 가능
- **HTTP/1.1의 한계**: Pipelining을 통해 요청은 연속적으로 보낼 수 있었지만, 응답은 반드시 요청 순서대로 와야 했음 → **HOL(Head-of-Line) Blocking** 문제 발생
- **HTTP/2 개선**: 각 요청/응답이 독립적으로 처리되어 병렬 전송 가능 → **리소스 로딩 속도 개선**

### 2. 헤더 압축 (HPACK)

- HTTP/1.1: 매 요청마다 같은 헤더(쿠키, User-Agent 등)가 반복 전송 → 네트워크 낭비
- HTTP/2: HPACK 압축 기법 적용
  - 중복 헤더 제거
  - Huffman 코딩 사용
- → 네트워크 트래픽 절감, 모바일 환경에서 특히 효과적

### 3. 서버 푸시 (Server Push)

- 서버가 클라이언트 요청을 기다리지 않고, **필요할 것으로 예상되는 리소스**를 미리 전송
- 예: HTML 요청 시 CSS, JS 파일을 함께 전송 → 초기 렌더링 속도 개선

### 4. Binary Protocol

- HTTP/1.1은 텍스트 기반 프로토콜 → 파싱 비용 큼
- HTTP/2는 **바이너리 프레이밍 계층** 도입 → 파싱 효율↑, 네트워크 전송 효율↑

## 보충 설명: HTTP/1.1의 Pipelining

- **작동 방식**:
  - 클라이언트가 한 번의 연결에서 여러 요청을 순차적으로 보냄
  - 서버는 요청을 처리해 **순서대로** 응답 반환
- **장점**: 응답을 기다리지 않고 연속 요청 가능 → 성능 일부 개선
- **단점**: 응답이 반드시 순서대로 와야 해서, 하나의 요청이 지연되면 뒤에 있는 요청 응답까지 지연됨 → **HOL Blocking 문제** 발생
- → 이 한계를 HTTP/2의 Multiplexing이 해결

## 프론트엔드와의 연관성

- **리소스 최적화 전략**이 달라짐
  - HTTP/1.1: 여러 요청을 줄이기 위해 **스프라이트 이미지, 번들링, 도메인 샤딩** 등 사용
  - HTTP/2: Multiplexing 덕분에 다수의 요청을 병렬 처리 가능 → **작은 단위 모듈화** 및 **코드 스플리팅** 전략 유리
- **성능 최적화**에서 HTTP/2 도입 여부에 따라 빌드/배포 전략이 달라짐

## 결론

- HTTP/2는 **Multiplexing, 헤더 압축, 서버 푸시, 바이너리 프로토콜**을 통해  
  기존 HTTP/1.1의 성능 한계를 해결하고 웹 리소스 로딩 속도를 크게 향상시켰다.
- 프론트엔드 개발자라면 HTTP/1.1과의 차이를 이해하고, **빌드 최적화 전략**을 프로토콜 특성에 맞게 조정할 수 있어야 한다.
