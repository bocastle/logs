# 자바스크립트 호이스팅(Hoisting) 정리

---

## 1) 호이스팅이란

- **정의**: 자바스크립트 엔진이 코드 실행 전에 수행하는 **생성 단계**(환경 레코드 구성)에서 **선언 정보를 먼저 등록**하기 때문에, 선언이 소스 코드보다 **앞에 있는 것처럼 보이는** 현상입니다.
- **주의**: “끌어올린다”는 **모형적 설명**입니다. 실제로는 **선언과 바인딩이 먼저 기록**되고, **초기화/할당은 실행 단계**에 일어납니다.

---

## 2) `var` vs `let`/`const` 와 TDZ

### 2-1. `var`

- **함수 스코프**(또는 전역)이며 **재선언/재할당 가능**.
- 호이스팅 시 **선언과 초기화(`undefined`)가 함께** 이뤄져, **선언 이전 접근**이 `undefined`로 평가됩니다.

```js
console.log(a); // undefined
var a = 10;
console.log(a); // 10
```

### 2-2. `let` / `const`

- **블록 스코프**, 재선언 불가. `let`은 재할당 가능, `const`는 **초기화 이후 재할당 불가**.
- **선언은 호이스팅되지만 초기화는 지연**됩니다. 선언 위치부터 초기화 시점까지 **TDZ(Temporal Dead Zone)** 에 놓이며, 접근 시 **ReferenceError**.

```js
console.log(b); // ReferenceError (TDZ)
let b = 10;
```

- `const`는 **선언과 동시에 초기화**가 필요합니다.

---

## 3) 함수와 호이스팅

### 3-1. **함수 선언식(Function Declaration)**

- **전체 함수 본문**이 호이스팅되어, 선언 이전 호출이 가능합니다.

```js
console.log(fn()); // "ok"
function fn() {
  return "ok";
}
```

### 3-2. **함수 표현식(Function Expression)**

- 변수에 **값으로 대입**된 함수는 **변수 규칙**을 따릅니다.

```js
console.log(f); // undefined (var의 경우), 호출하면 TypeError
var f = function () {};
```

```js
console.log(g); // ReferenceError (TDZ: let/const)
let g = () => {};
```

> 결론: “선언식은 먼저 쓸 수 있다, 표현식은 변수 규칙을 따른다.”

---

## 4) 클래스(Class)와 호이스팅

- **클래스 선언**도 호이스팅되지만, **초기화 이전 접근은 TDZ**에 걸립니다.

```js
const c = new C(); // ReferenceError (TDZ)
class C {}
```

- **클래스 표현식** 역시 변수 규칙을 따릅니다(`let/const` 권장).

---

## 5) 모듈(ESM)과 호이스팅

- ES 모듈은 **정적 구조**를 가지며, `import`/`export`는 **파일 최상단으로 호이스팅**됩니다.
- `import`는 **읽기 전용 라이브 바인딩**으로, **TDZ**가 적용되고 **순환 참조 시 초기화 타이밍**에 유의해야 합니다.

```js
// a.js
console.log(x); // ReferenceError (TDZ)
import { x } from "./b.js";
```

---

## 6) 스코프별 요약 표

| 구분        | 스코프        | 재선언 | 재할당 | 선언 전 접근            | 비고                  |
| ----------- | ------------- | ------ | ------ | ----------------------- | --------------------- |
| `var`       | 함수/전역     | 가능   | 가능   | `undefined`             | 초기화 동반 호이스팅  |
| `let`       | 블록          | 불가   | 가능   | **ReferenceError**(TDZ) | 선언만 호이스팅       |
| `const`     | 블록          | 불가   | 불가   | **ReferenceError**(TDZ) | 선언 즉시 초기화 필요 |
| 함수 선언   | 함수/블록(ES) | N/A    | N/A    | **호출 가능**           | 본문 전체 호이스팅    |
| 클래스 선언 | 블록          | N/A    | N/A    | **ReferenceError**(TDZ) | 선언 전 사용 불가     |
| import      | 모듈          | N/A    | N/A    | **ReferenceError**(TDZ) | 정적, 상단 호이스팅   |

---

## 7) 흔한 함정

1. **변수 끌어올림으로 인한 `undefined` 접근**
   - `var` 사용 시 선언 전 접근이 **조용히 `undefined`** 가 되어 버그 은닉.
2. **TDZ 오해**
   - `let`/`const`는 “호이스팅 안 된다”가 아니라 **선언은 되지만 초기화 전 접근이 금지**되는 것입니다.
3. **함수 표현식의 호출 타이밍**
   - `const f = () => {}` 선언 **이전** 호출은 **ReferenceError**.
4. **클래스/모듈의 TDZ**
   - 클래스는 **선언 전 인스턴스화 불가**, ESM의 `import`도 **TDZ**가 있습니다.

---

## 8) 모범 사례

- **기본값: `const`**, 필요한 곳에만 `let`, **`var`는 지양**합니다.
- **선언을 사용 지점 근처**에 두고, **파일/블록 상단에서 초기화**를 명확히 합니다.
- **함수는 선언식 또는 화살표 함수**를 일관성 있게 사용하고, 호출 시점을 선언 이후로 유지합니다.
- 모듈은 **정적 `import`** 를 사용하고, 동적 로딩이 필요할 때만 `import()`를 사용합니다.
- 린터/타입체커(ESLint/TypeScript)로 **사용 전 선언** 규칙을 강제합니다.

---

## 9) 요약

- 호이스팅은 **선언이 먼저 등록**되기 때문에 생기는 **가시적 효과**입니다.
- `var`는 **`undefined` 초기화가 동반**되고, `let`/`const`/`class`/`import`는 **TDZ**로 인해 **선언 전 접근 시 ReferenceError**가 발생합니다.
- 실무에서는 **`const`/`let` + 명확한 선언 순서**로 호이스팅 부작용을 예방하는 것이 가장 안전합니다.
