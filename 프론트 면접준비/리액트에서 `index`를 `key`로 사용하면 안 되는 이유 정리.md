# 리액트에서 `index`를 `key`로 사용하면 안 되는 이유 정리

> 리스트 렌더링에서 `key`는 **요소 식별자**입니다. `key`가 바뀌면 리액트는 **다른 요소**로 간주하고 재마운트하며, `key`가 안정적으로 유지되면 기존 요소로 간주해 **상태와 DOM을 재사용**합니다. 따라서 **데이터와 1:1로 안정적으로 매핑되는 고유 값**을 `key`로 사용해야 합니다.

---

## 1) 왜 `index`를 `key`로 쓰면 문제가 되는가

### 1.1 순서 변경/삽입/삭제 시 `key` 변동

- 배열 **앞쪽에 삽입**하거나 **중간 요소 삭제** 시, 뒤쪽 모든 요소의 `index`가 달라집니다.
- 리액트는 변경된 `index`를 보고 **완전히 다른 항목**으로 판단 → **불필요한 재마운트** 및 **상태 유실**.

### 1.2 상태 보존 오류

- 입력 필드/토글/포커스/컴포넌트 내부 상태가 **이웃 항목으로 이동**하거나 **초기화**되는 현상.
- 예: 체크박스 리스트에서 한 항목을 삭제하자 **아래 항목의 체크 상태가 위로 올라가** 버림.

### 1.3 성능 저하

- 재마운트 증가로 **비용 큰 컴포넌트**(차트, 이미지, 에디터 등)에서 **불필요한 렌더/이펙트 재실행** 발생.

### 1.4 UI 이상 동작 시나리오

- **필터/정렬/페이지네이션/가상 스크롤/드래그 앤 드롭** 조합에서 `index` 키는 거의 반드시 문제를 유발.
- **애니메이션/트랜지션**(예: React Transition Group)에서 항목 매칭 실패로 **어색한 전환**.

> 핵심: `key`는 **항목의 정체성(Identity)** 입니다. `index`는 **위치**일 뿐, 정체성이 아닙니다.

---

## 2) 언제 `index` 사용이 허용되는가

- **완전히 정적**이며 **삽입/삭제/정렬 변경이 절대 발생하지 않는** 리스트.
- **렌더링 한 번으로 끝**나고 사용자 상호작용·상태 보존이 **전혀 필요 없는** 단순 목록.
- 빌드 타임에 **고정된 배열 상수**를 출력하는 경우.

> 위 조건이 하나라도 깨질 가능성이 있으면 **`index`를 사용하지 마십시오.**

---

## 3) 올바른 `key` 선택 방법

### 3.1 서버/DB가 제공하는 **불변 ID** 사용(권장)

```tsx
{
  items.map((item) => <Row key={item.id} item={item} />);
}
```

### 3.2 **자연 키/복합 키** 구성

- 예: `orderId + lineNo`, `userName + createdAt` 등 **업무적으로 유일**하고 **변하지 않는** 조합.

```tsx
const keyOf = (o: OrderLine) => `${o.orderId}_${o.lineNo}`;
{
  lines.map((l) => <Line key={keyOf(l)} data={l} />);
}
```

### 3.3 **해시 기반 키**

- 내용이 **변하지 않는 항목**에 한해, 안정적 해시(예: `xxhash`, `md5` of stable fields) 사용.
- 내용 변경이 잦다면 키 변경으로 재마운트가 발생할 수 있으므로 주의.

### 3.4 **클라이언트에서 생성하되, 한번만**(중요)

- `uuid/cuid/nanoid` 등을 **생성 시점에 1회** 할당하고 **영속 보관**:
  - 서버에 저장하거나
  - 메모리 상에서는 **`useRef`/상태**에 저장하여 **리렌더마다 새로 만들지 않기**

```tsx
function useStableKeys(items) {
  const mapRef = React.useRef(new Map());
  return items.map((item) => {
    if (!mapRef.current.has(item.tempIdentity)) {
      mapRef.current.set(item.tempIdentity, crypto.randomUUID());
    }
    return { ...item, _key: mapRef.current.get(item.tempIdentity) };
  });
}
```

> 금지 패턴: `key={Math.random()}` 또는 렌더링마다 새 UUID 생성 — **매 렌더 재마운트** 유발.

---

## 4) 흔한 버그 예시

### 4.1 입력 상태가 밀리는 문제

```tsx
{todos.map((t, i) => (
  <input key={i} value={t.text} onChange={...} />
))}
// 첫 번째 항목 삭제 시, 두 번째 인풋의 값/커서/포커스가 첫 번째로 '이동'
```

### 4.2 드래그 앤 드롭에서 항목 뒤바뀜

- 위치 이동으로 `index`가 바뀌어 **다른 항목의 DOM을 재사용**, 시각·상태 불일치.

### 4.3 리스트 애니메이션 꼬임

- 트랜지션 라이브러리에서 항목 매칭 실패로 **겹침/잔상** 발생.

---

## 5) 점검 체크리스트

- [ ] `key`가 **데이터의 정체성**을 나타내는가(불변·고유)?
- [ ] 정렬/필터/삽입/삭제/드래그 등 **순서 변화**가 발생해도 `key`가 **안정적**인가?
- [ ] 클라이언트 생성 키는 **한 번만 생성**되어 **리렌더 간 유지**되는가?
- [ ] **랜덤/인덱스** 키를 사용하지 않았는가?
- [ ] 애니메이션/가상 스크롤/폼 상태와의 **상호작용 테스트**를 거쳤는가?

---

## 6) 요약

- `key`는 리스트 항목의 **정체성 식별자**이며, **리렌더 간 안정성**이 핵심입니다.
- `index` 키는 리스트 수정/정렬/삭제 시 **재마운트/상태 유실/성능 저하**를 유발합니다.
- 가능하면 **서버 제공 ID**를, 없으면 **변하지 않는 복합 키나 1회 생성한 안정 키**를 사용하십시오.
