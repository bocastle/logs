# 전역 상태 관리가 필요한 이유와 도입 가이드

## 1) 전역 상태 관리가 해결하는 문제

- **상태 공유의 복잡성 축소**: 여러 컴포넌트 간 공통 상태를 중앙화하여 `props drilling` 없이 접근.
- **관심사 분리**: UI는 표현에 집중, 상태 변경 로직은 별도의 스토어/리듀서로 분리 → 테스트 용이.
- **성능 제어 지점 확보**: 부분 구독, 셀렉터, 메모이제이션 등으로 **불필요한 리렌더**를 억제.

> 전역 상태는 **클라이언트 상태**(폼, 토글, 모달, 캐싱 불필요) 중심으로 관리하고, **서버 상태**(API 데이터)는 TanStack Query 등으로 별도 관리하는 것이 일반적입니다.

---

## 2) 도입 판단 기준 (오버엔지니어링 방지)

- 컴포넌트 3곳 이상에서 동일 상태를 **자주** 읽고/갱신한다.
- 상태 흐름이 복잡해 디버깅 시간이 커졌다 (순수 함수 기반 관리 필요).
- 특정 상태 변경이 **국지적**으로만 리렌더되길 원한다 (부분 구독 필요).
- 반대로, 규모가 작고 상태 공유가 단순하면 `useState + useContext`로 충분.

---

## 3) 대표 라이브러리와 특성

### Redux Toolkit (RTK)

- 불변성/리듀서 보일러플레이트 최소화, 미들웨어·DevTools 생태계 풍부.
- **RTK Query**로 서버 상태까지 포괄 가능(단, 클/서버 상태 구분 의식은 유지).

### Zustand

- 매우 가벼운 스토어. **셀렉터 기반 부분 구독**으로 리렌더 최소화.
- 코어 API가 단순하여 점진 도입/분리가 용이.

### Recoil / Jotai

- **원자 단위** 상태 모델(작게 쪼개 구독). 파생 상태(Selector, Atom Family) 구성 용이.
- 복잡한 의존성 그래프를 가진 UI에 유리.

### MobX

- **관찰자 패턴** 기반 반응형 모델. 객체지향/클래스 친화. 학습 방향이 다름.

> “무엇을” 관리할지, 팀 경험/디버깅 도구, 성능 문제 양상에 맞춰 선택합니다.

---

## 4) 성능 최적화 체크리스트

- **부분 구독(Selectors)**: 필요한 조각만 구독하여 리렌더 범위 축소.
- **파생 값 메모이제이션**: `reselect`, `useMemo`로 고비용 계산 캐시.
- **정규화(Normalization)**: 엔티티-아이디 맵 구조로 갱신 범위 최소화.
- **불변 업데이트 보장**: RTK/Immer 활용으로 변경 감지 정확도↑.
- **스토어 분리**: 독립적인 도메인 상태는 스토어/원자 분리.
- **배치 업데이트**: React 18은 기본 배치, 필요 시 `unstable_batchedUpdates` 고려.
- **서버 상태는 캐싱 라이브러리**로 위임(TanStack Query).

---

## 5) 패턴 비교: Context vs 전역 스토어

- **Context 단독**: 값이 자주 바뀌면 **트리 전반 리렌더** 위험. 값 자체를 넣기보다 **구독 훅/셀렉터 패턴**으로 누수 감소.
- **전역 스토어**: 부분 구독/미들웨어/타임트래블 등 운영 도구 제공. 복잡도에 비례해 이점 상승.

---

## 6) 동시성·라우팅과의 경계

- **동시성(Transition)**: 낮은 우선순위 업데이트는 `startTransition`으로 랙 최소화.
- **Suspense**: 서버 상태 대기는 Suspense로, 전역 클라이언트 상태는 즉시성 유지.
- **URL 상태**: 검색어/페이지네이션 등은 **URL(QueryString)** 로 승격하여 새로고침/공유 용이.

---

## 7) 도입·마이그레이션 전략

1. 우선 **서버 상태는 Query 라이브러리**로 분리.
2. 남은 클라이언트 상태 중, 공유/빈도/복잡성이 높은 도메인부터 전역화.
3. 성능 이슈 경로에만 **부분 구독**과 **정규화** 적용.
4. DevTools(예: Redux DevTools, Recoil DevTools)로 변경 흐름 추적.

---

## 8) 간단 예시 (Zustand 부분 구독)

```ts
import { create } from "zustand";

type CartItem = { id: string; qty: number };
type State = {
  items: Record<string, CartItem>;
  add: (id: string) => void;
};

export const useCart = create<State>((set) => ({
  items: {},
  add: (id) =>
    set((s) => ({
      items: {
        ...s.items,
        [id]: { id, qty: (s.items[id]?.qty ?? 0) + 1 },
      },
    })),
}));

// 부분 구독 – 해당 아이템 개수만 구독하여 리렌더 최소화
export function ItemQty({ id }: { id: string }) {
  const qty = useCart((s) => s.items[id]?.qty ?? 0);
  return <span>{qty}</span>;
}
```

---

## 9) 요약

- 전역 상태 관리는 **공유/빈번/복잡** 상태에서 가치를 발휘.
- 서버 상태와 클라이언트 상태를 **역할 분리**하여 혼합 복잡도 감소.
- 부분 구독·정규화·메모이제이션으로 **정밀한 성능 제어**.
