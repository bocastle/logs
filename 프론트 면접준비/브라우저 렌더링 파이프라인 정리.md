# 브라우저 렌더링 파이프라인 정리

> 본 문서는 현대 브라우저(Chromium/Blink 중심, WebKit/Gecko 유사)의 렌더링 파이프라인을 **개념 → 단계 → 변경 트리거 → 최적화** 순서로 정리합니다.

---

## 1) 큰 흐름(6단계)

1. **DOM 생성 (HTML Parsing → DOM Tree)**

   - 네트워크로 받은 HTML 바이트 → 문자 → 토큰 → 노드로 변환하여 **DOM 트리** 구성.
   - `<script>`는 기본적으로 **파싱을 차단**합니다(단, `defer`/`async`/`module` 등으로 차단 완화 가능).

2. **CSSOM 생성 (CSS Parsing → CSSOM Tree)**

   - CSS 바이트 → 토큰/규칙으로 파싱하여 **CSSOM 트리** 구성.
   - CSS는 **렌더-블로킹**이므로 파싱 완료 전까지 화면 그리기가 지연될 수 있습니다.

3. **렌더 트리 생성 (Render Tree / Frame Tree)**

   - DOM × CSSOM 결합 → **시각적으로 표시되는 노드만** 포함(예: `display: none` 제외).
   - 각 노드는 계산된 스타일(Computed Style)을 가진 **박스(box)** 로 매핑됩니다.

4. **레이아웃(리플로우) (Layout)**

   - 렌더 트리 박스의 **기하(위치·크기)** 계산.
   - 뷰포트 크기, 글꼴 메트릭, 흐름, 플렉스/그리드, 컨테이너 쿼리 등 레이아웃 규칙 반영.

5. **페인팅 (Paint)**

   - 텍스트/배경/테두리/그림자/이미지 등 **시각 속성**을 **그리기 명령(Display List)** 로 변환.

6. **컴포지팅 (Compositing)**
   - 요소를 **레이어**로 분리 → GPU가 **레이어 합성**.
   - `transform`, `opacity` 중심의 **컴포지트 전용** 업데이트는 레이아웃·페인트 없이 합성만으로 처리되어 **부드러운 애니메이션**에 유리.

---

## 2) 변경에 따른 재계산 단계

| 변경 유형         | 예시                                                             | 스타일 재계산 | 레이아웃 | 페인트 | 컴포지팅 |
| ----------------- | ---------------------------------------------------------------- | :-----------: | :------: | :----: | :------: |
| **컴포지트 전용** | `transform`, `opacity`                                           |      〇       |    –     |   –    |    〇    |
| **페인트 필요**   | `background`, `color`, `box-shadow`                              |      〇       |    –     |   〇   |    〇    |
| **레이아웃 필요** | `width/height`, `margin`, `position`, `font-size`, DOM 추가/삭제 |      〇       |    〇    |   〇   |    〇    |

> 실제 파이프라인은 **스타일 → 레이아웃 → 페인트 → 컴포지트**의 **의존 사슬**을 따릅니다. 상위 단계가 변하면 하위 단계가 **연쇄적으로** 유발됩니다.

---

## 3) 레이아웃/페인트가 재실행되는 주요 트리거

- **레이아웃 트리거**
  - 기하 변경: `width/height/top/left/margin/padding/border`, 글꼴 로드, 이미지 고유 크기 확정, 컨테이너 쿼리 등
  - **레이아웃 스래싱**: 레이아웃을 강제 측정(`offsetWidth`, `getBoundingClientRect`) 후 바로 쓰기 반복
- **페인트 트리거**
  - 색/배경/그림자/윤곽/필터 등 **시각 레벨** 변경
  - 복잡한 페인트(큰 blur, 많은 박스-쉐도우, 배경 고정 등)는 페인트 비용 급증
- **컴포지트 전용**
  - `transform: translate/scale/rotate`와 `opacity` 중심(필요 시 `will-change`/애니메이션 선언으로 레이어 승격)

---

## 4) 단계별 상세

### DOM

- 스크립트 실행은 DOM에 영향(노드 생성/삭제/속성 변경).
- `defer` 스크립트는 파싱 차단 없이 **DOMContentLoaded 직전** 실행, `async`는 다운로드 완료 즉시 실행(순서 비보장).

### CSSOM

- **특이성/상속/계산값** 해결 후 각 노드에 **Computed Style** 부여.
- 크고 복잡한 셀렉터는 스타일 계산 비용을 증가시킬 수 있습니다.

### 렌더 트리

- `visibility: hidden`은 렌더 트리에 **포함**(공간 차지)하나, 페인트 시 보이지 않음.
- `display: none`은 **제외**.

### 레이아웃

- 플로우/플렉스/그리드/테이블 등 **레벨별 알고리즘**이 다름.
- 폰트 교체(FOUT/FOIT), 이미지 지연 로드 시 재레이아웃 발생 가능.

### 페인팅

- 브라우저는 **Display List**(그리기 명령 목록)를 만들고 **RASTER** 합니다.
- 큰 스크롤 영역/고해상도 화면에서 페인트 비용이 커질 수 있습니다.

### 컴포지팅

- **레이어 분리**: 3D 변환, `position: fixed`, CSS 애니메이션, `will-change` 등이 레이어 후보.
- 레이어 과다 분리는 메모리와 합성 비용을 증가시킬 수 있으므로 **필요 최소화**.

---

## 5) 성능 최적화 체크리스트

- **렌더 블로킹 감소**
  - CSS는 **상단 1개 핵심 파일**로 병합/경량화, 사용하지 않는 CSS 제거.
  - JS는 `defer`/`async`/`type="module"` 적극 활용.
- **레이아웃 최소화**
  - 레이아웃 강제 측정 호출을 **배치**하고, 읽기→쓰기 순서로 **단락화(batch)**.
  - 대량 DOM 업데이트는 **문서 프래그먼트**/오프스크린(가상 DOM, `display: contents`, `content-visibility`) 활용.
- **페인트 비용 절감**
  - 큰 blur/gradient/box-shadow 남용 자제, **이미지 크기/포맷** 최적화(AVIF/WebP/SVG).
  - 스크롤 성능: **paint containment**(`contain: paint`) 고려.
- **컴포지트 전용 애니메이션**
  - 가능하면 `transform`/`opacity`로 설계, 필요 시 `will-change`로 사전 승격(남발 금지).
  - 스크롤-연동 애니메이션은 **`scroll-timeline`**(지원 브라우저) 검토.
- **지연/가시성 기반 렌더링**
  - `loading="lazy"`, `fetchpriority`, `priority hints`, `IntersectionObserver` 로 초기 비용 축소.
- **DevTools 활용**
  - Performance 패널로 **Recalculate Style / Layout / Paint / Composite** 비용을 측정.
  - Rendering 탭의 **Paint flashing / FPS meter**로 병목 지점을 찾아 개선.

---

## 6) 실전 패턴

- **목록 가상화**: 수천 개 리스트는 **윈도우링**으로 표시 영역만 렌더.
- **스켈레톤 UI**: 초기 렌더 지연 체감 감소, LCP 개선.
- **Critical Rendering Path(CRP)** 관리: **HTML → CSS → 폰트/이미지** 우선순위 조정으로 FCP/LCP 개선.
- **앱 셸 아키텍처(PWA)**: 셸 먼저, 콘텐츠 스트리밍.
- **Containment & Subtree**: `content-visibility: auto; contain-intrinsic-size: ...` 로 **서브트리 지연 계산**.

---

## 7) 요약

- 렌더링 파이프라인은 **DOM → CSSOM → 렌더 트리 → 레이아웃 → 페인트 → 컴포지팅**입니다.
- 변경이 상위 단계에 가까울수록 **연쇄 비용**이 큽니다. 가능하면 **컴포지트 전용 업데이트**로 유지하십시오.
- **렌더 블로킹 자원**을 줄이고, **레이아웃/페인트 트리거**를 통제하며, **DevTools 측정**을 통해 병목을 정확히 파악·개선하는 것이 핵심입니다.
