# 웹 애플리케이션 성능 최적화 종합 정리

> 본 문서는 프런트엔드 관점 중심으로 **네트워크·렌더링·자바스크립트·이미지/폰트·캐싱/배포·관측/프로세스**까지 실무에서 적용 가능한 최적화 전략을 체계적으로 정리합니다. (SPA/MPA/SSR/SSG, React 18 기준 내용 포함)

---

## 1) 우선순위와 측정: 목표를 수치로 정의

- **핵심 지표(Core Web Vitals)**: LCP(최대 콘텐츠 표시), INP(상호작용 지연), CLS(누적 레이아웃 이동).
- **네트워크·JS·레이아웃 비용**의 상충을 이해하고 **퍼포먼스 버짓**(예: 초기 JS ≤ 170KB gz, LCP ≤ 2.5s)을 설정.
- 도구: **Lighthouse**, **WebPageTest**, **Chrome DevTools Performance/Network/Coverage**, **Core Web Vitals RUM(실사용 데이터)**.
- **성능 예산 실패 시 PR 차단** 등 **프로세스화**.

---

## 2) 전송(네트워크) 최적화

### 2.1 자바스크립트 로딩 전략

- **코드 스플리팅**: 라우트/기능 단위 분할(예: React.lazy + Suspense, dynamic import). 초기 로드 핵심만 선적재.
- **지연/비동기 로딩**: `<script defer>`(DOMContentLoaded 전까지 다운로드·파싱 병렬, 실행은 HTML 파싱 후), `<script async>`(다운로드 병렬, 준비 즉시 실행; 의존성 순서 주의).
- **Tree‑Shaking/ESM**: side‑effect‑free 표기, ESM 번들, “dead code” 제거.
- **서드파티 제어**: 태그 관리에서 **지연/허용 목록화**, 교차 모니터링(크리티컬 경로 침범 방지).

### 2.2 HTTP/2/3 활용

- **멀티플렉싱** 전제에서 **도메인 샤딩/과도 번들링** 지양.
- **Preconnect / DNS‑prefetch / Preload**로 초기 왕복(RTT) 최소화.
- **Brotli 압축**(br) 우선, 없으면 gzip. 텍스트 리소스에 적용.

### 2.3 캐싱 정책

- **정적 불변**: `Cache-Control: public, max-age=31536000, immutable` + **파일명 해시**(fingerprint).
- **변경 가능**: `ETag`/`Last-Modified`로 조건부 요청.
- **Service Worker**: 앱 셸 캐싱, 오프라인/저대역 대응(전략: stale‑while‑revalidate 등).
- **CDN**: 에지 캐시·HTTP/2/3 종단, 이미지/동영상 전달 최적화.

---

## 3) 렌더링 경로 최적화(Critical Rendering Path)

- **Critical CSS** 인라인(Above‑the‑Fold 최소화) + 나머지 CSS **비동기 로드**(media 속성/`rel="preload"`→`rel="stylesheet"` 전환).
- **폰트 최적화**:
  - 포맷: **WOFF2**, **서브셋**(필요 글립만), **가변 폰트** 검토.
  - `font-display: swap`으로 FOUT 허용, 또는 `optional`(빠른 폴백).
  - Preload로 **첫 페인트 차단 방지**.
- **블로킹 스크립트 제거**: 크리티컬 경로에서 동기 스크립트 지양.
- **레이아웃 스래싱 방지**: 읽기와 쓰기 분리(메저→스타일→레이아웃 순), `requestAnimationFrame`로 배치.

---

## 4) 이미지/미디어 최적화

- **포맷 선택**: WebP/AVIF(손실/무손실) → JPEG/PNG 대비 용량 대폭 절감.
- **Responsive Image**: `srcset`/`sizes`로 뷰포트별 적정 해상도 제공.
- **지연 로딩**: 네이티브 `loading="lazy"`, 폴드 아래 이미지 지연.
- **디코딩/우선순위 힌트**: `decoding="async"`, `fetchpriority="high"`(히어로 이미지), `priority`(Next.js).
- **CDN 변환**: 에지에서 리사이즈/포맷 변환(장치별 자동 최적화).

---

## 5) 자바스크립트 실행 비용 절감

- **컴포넌트 비용 관리**: 메모이제이션(`React.memo`, `useMemo`, `useCallback`)은 **핫스팟** 위주로 적용(오남용 시 역효과).
- **이벤트 제어**: **쓰로틀/디바운스**/rAF 쓰로틀로 과도한 핸들러 억제.
- **리스트 가상화**: 수천 개 DOM 노드 대신 **가시 영역만 렌더**(react-window, react-virtualized).
- **Web Worker**: 메인 스레드를 막는 **무거운 계산**을 분리. WASM 검토(이미지 처리/파싱 등).
- **불필요 JS 제거**: 사용량 낮은 기능은 **옵트인 로딩**, **서드파티 스크립트 다이어트**.

---

## 6) React/Next.js 특화 전략

- **SSR/SSG**: 첫 페인트/SEO 개선, **스트리밍 SSR + Suspense**로 점진 렌더.
- **Partial/Selective Hydration**(React 18 + 프레임워크 기능): 필요한 섬만 하이드레이트.
- **React Server Components(RSC)**: 서버에서 **JS 실행/데이터 패칭** 후 결과만 전송 → 클라이언트 JS 감축.
- **Route 기반 코드 분할**: dynamic import + `<Suspense>` 로 화면 단위 스플리팅.
- **데이터 패칭**: **중복 요청 방지**(SWR/TanStack Query 캐시), **stale‑while‑revalidate**로 체감 반응 향상.
- **Strict Mode/Profiler**로 숨은 재렌더·부작용 검출.

---

## 7) 레이아웃/스타일 성능

- **CLS 억제**: 이미지/광고 슬롯에 **크기 예약**(width/height 또는 aspect‑ratio).
- **복잡한 애니메이션**: 레이아웃/페인트 대신 **컴포지팅 속성**(`transform`, `opacity`) 사용.
- **큰 테이블/그리드**: **sticky**/virtual scroll 조합, CSS contain 사용(`contain: content/layout`)으로 격리.
- **GPU 과사용 방지**: `will-change`는 **필요 구간만**.

---

## 8) 백엔드/API 연계 최적화(프런트 영향 큰 항목)

- **지연 감소**: 에지/리전 선택, Keep‑Alive/HTTP/2, 압축/캐시 헤더.
- **쿼리 최적화/페이지네이션**: 필요한 필드만, N+1 제거, 적절한 페이지 크기.
- **Batching/병렬화**: GraphQL **DataLoader**, HTTP/2 **동시 요청**.
- **Etag/If-None-Match**로 **차등 전송**.

---

## 9) 보급형 최적화 체크리스트

- [ ] 초기 번들 크기(압축 후) 예산 준수
- [ ] 라우트/기능 코드 스플리팅 적용
- [ ] 크리티컬 CSS 인라인, 나머지 비동기 로드
- [ ] 히어로 이미지 preload + 적정 포맷(WebP/AVIF)
- [ ] `<script defer>` 기본, 동기 스크립트 제거
- [ ] 이미지/폰트 서브셋 + `font-display: swap`
- [ ] 캐시 정책(immutable + hash), CDN 배포
- [ ] 서비스 워커로 오프라인/낮은 대역폭 대응
- [ ] 이벤트 쓰로틀/디바운스, 리스트 가상화
- [ ] Core Web Vitals 모니터링(RUM)과 퍼포먼스 버짓 운영

---

## 10) 운영/관측

- **RUM**: 실사용자 성능 수집(퍼센타일 75 기준 목표).
- **에러·성능 통합 대시보드**: Sentry, New Relic, Grafana + Web Vitals.
- **릴리즈 후 회귀 탐지**: 번들 사이즈 경고, Lighthouse CI, SpeedCurve.

---

## 11) 우선순위 로드 설계 예시(의사 코드)

```html
<!-- 1) Preconnect: 폰트/CDN -->
<link rel="preconnect" href="https://cdn.example.com" crossorigin />

<!-- 2) Hero 이미지 우선 로드 -->
<link rel="preload" as="image" href="/img/hero.avif" fetchpriority="high" />

<!-- 3) Critical CSS 인라인 + 나머지 비동기 -->
<style>
  /* above-the-fold 최소 스타일 */
</style>
<link
  rel="preload"
  as="style"
  href="/assets/app.css"
  onload="this.rel='stylesheet'"
/>

<!-- 4) 스크립트는 defer 기본 -->
<script type="module" src="/assets/entry.js" defer></script>
```

---

## 12) 요약

- **적게, 빨리, 늦게**: 전송량을 **줄이고**, 필요한 것은 **빨리**, 나머지는 **늦게**.
- **측정 기반 반복**: 지표·예산·자동화로 **일회성 최적화**를 **지속 가능한 체계**로 만드십시오.
- 프런트와 백엔드, 빌드/배포, 관측이 **유기적으로 연결**될 때 **체감 성능**이 극대화됩니다.
