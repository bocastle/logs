# 테스트하기 쉬운 코드의 조건 (프론트엔드 중심)

---

## ✅ 1. **순수 함수 (Pure Function)**

- **정의**: 동일한 입력에 대해 항상 동일한 출력을 반환하며, 부수 효과(Side Effect)가 없는 함수
- **예시**:
  ```ts
  // 순수 함수 예시
  function add(a: number, b: number): number {
    return a + b;
  }
  ```
- **테스트 용이성**:
  - 외부 상태에 의존하지 않기 때문에 독립적으로 테스트 가능
  - DOM 조작, API 호출 등이 없는 함수는 mocking 없이도 테스트 가능

---

## ✅ 2. **단일 책임 원칙 (Single Responsibility Principle)**

- **정의**: 하나의 함수(또는 모듈)는 하나의 역할만 수행해야 한다.
- **예시 (나쁜 예)**:
  ```ts
  async function fetchAndRenderUser(id: string) {
    const res = await fetch(`/api/users/${id}`);
    const data = await res.json();
    document.querySelector("#username").textContent = data.name;
  }
  ```
- **개선된 예**:

  ```ts
  async function fetchUser(id: string) {
    const res = await fetch(`/api/users/${id}`);
    return await res.json();
  }

  function renderUser(user: { name: string }) {
    document.querySelector("#username").textContent = user.name;
  }
  ```

- **테스트 용이성**:
  - 각 함수가 독립적으로 작동 → 각각 단위 테스트 작성이 쉬움

---

## ✅ 3. **예측 가능한 코드 (Predictable Code)**

- **작성 팁**:
  - 명확한 변수명
  - 일관된 스타일
  - 사이드 이펙트 제거
  - 예외 상황 최소화
- **예시 (예측 불가능한 코드)**:
  ```ts
  let count = 0;
  function unpredictable() {
    return ++count;
  }
  ```
- **예측 가능한 코드 예**:
  ```ts
  function predictable(a: number, b: number): number {
    return a + b;
  }
  ```

---

## ⚠️ 테스트를 위한 코드 변경, 괜찮은가?

- **지양해야 하는 예**:

  - 테스트를 위해 `private` → `public`으로 변경
  - 테스트용 메서드 추가 등

- **권장하는 접근**:
  - 테스트가 어려운 코드는 **리팩토링이 필요한 신호**
  - 의존성 분리, 모듈화 등으로 테스트 가능하도록 개선

---

## 🧠 요약

| 조건             | 설명                                            |
| ---------------- | ----------------------------------------------- |
| 순수 함수        | 외부 상태에 의존하지 않음, 독립적인 테스트 가능 |
| 단일 책임 원칙   | 하나의 역할만 하도록 설계, 테스트가 명확해짐    |
| 예측 가능한 코드 | 테스트 시 의도치 않은 결과 방지                 |
| 리팩토링 관점    | 테스트가 어렵다면 코드 자체를 개선할 시점       |
