# 테스트 격리(Test Isolation)

## 📌 개념

테스트 격리(Test Isolation)란 **각 테스트가 서로 독립적으로 실행되도록 보장**하는 것을 의미합니다.  
즉, 한 테스트의 실행 결과나 상태가 다른 테스트에 영향을 주지 않아야 합니다.

---

## 📌 왜 중요한가?

테스트 격리가 제대로 되지 않으면 **비결정적 테스트(Non-deterministic Test)** 가 발생할 수 있습니다.  
비결정적 테스트란, 같은 테스트를 여러 번 실행했을 때 항상 같은 결과를 내지 않는 테스트를 말합니다.

예시:

- 테스트가 **공유 자원(DB, 파일, 캐시 등)** 에 의존할 경우
- 실행 순서나 다른 테스트의 실행 여부에 따라 성공/실패가 달라짐
- 실패했을 때, **실제 코드 문제인지 환경 문제인지 구분하기 어려움**

👉 따라서 **테스트는 항상 동일한 조건에서 예측 가능한 결과**를 낼 수 있어야 하며, 이를 위해 격리가 필요합니다.

---

# Spring에서 DB를 사용하는 테스트의 격리 방법

## ✅ 1. `@DirtiesContext`

```java
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@SpringBootTest
class MyIntegrationTest {
    // ...
}
```

- 테스트마다 **새로운 ApplicationContext 로드**
- **완벽한 격리 보장**
- 하지만 ApplicationContext 로딩 비용이 크므로 **성능 저하** 발생

## ✅ 2. `@Sql`

```java
@Sql("/truncate.sql")
@SpringBootTest
class MyIntegrationTest {
    // ...
}
```

- 테스트 실행 전/후에 특정 **SQL 스크립트 실행**
- `TRUNCATE` 등을 사용해 **DB 테이블 초기화** 가능
- 단점: **테이블이 늘어날 때마다 SQL 스크립트 수정 필요 → 유지보수 비용 증가**

---

## ✅ 3. `@Transactional`

```java
@Transactional
@SpringBootTest
class MyIntegrationTest {
    // ...
}
```

## ✅ 3. `@Transactional` — 핵심 요약

- 테스트 실행 후 트랜잭션을 **롤백하여 DB 상태 유지**
- **성능상 가장 효율적인 방법**
- 단, **주의할 점 존재** 👇

---

### ⚠️ 주의 사항

1. **프로덕션 환경과 다른 트랜잭션 조건**

   - 예: OSIV를 끈 상태에서 `LazyInitializationException`이 발생해야 하는 코드가  
     테스트에서는 트랜잭션이 열려 있어 **성공하는 거짓 음성(False Negative)** 발생 가능

2. **거짓 결과 가능성**

   - **거짓 양성(False Positive)**: 프로덕션 코드는 정상인데 테스트는 실패
   - **거짓 음성(False Negative)**: 프로덕션 코드는 실패인데 테스트는 성공

3. **트랜잭션 롤백이 적용되지 않는 경우**
   - `@SpringBootTest`의 `WebEnvironment`가 `DEFINED_PORT` 또는 `RANDOM_PORT`일 때  
     → 별도 스레드에서 서블릿 컨테이너 실행
   - 전파 레벨이 `REQUIRES_NEW`인 경우  
     → **새로운 트랜잭션 생성**, 테스트 트랜잭션과 분리되어 **롤백 미적용**
   - **비동기 메서드 실행** 시  
     → 새로운 스레드에서 수행되어 **롤백 미적용**
