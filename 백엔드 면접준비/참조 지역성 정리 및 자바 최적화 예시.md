# 참조 지역성(Locality of Reference) 정리 및 자바 최적화 예시

> 캐시 적중률을 높여 메모리 병목을 줄이기 위한 **시간 지역성·공간 지역성**의 활용과, 자바 2차원 배열 순회 패턴 개선을 다룹니다.

---

## 1) 개념 요약

- **시간 지역성(Temporal locality)**: 최근 접근한 데이터/코드에 **다시 접근**하는 경향. 예: 루프 내 동일 변수 재사용, 반복 호출 함수.
- **공간 지역성(Spatial locality)**: 한 위치에 접근하면 **근처 데이터**에 접근할 가능성↑. 예: 배열의 연속 원소 순회.
- **목표**: 캐시라인(대개 64B)을 **효율적으로 채우고** 같은 라인을 여러 연산에 활용하여 **메모리 대기 시간**을 줄임.

---

## 2) 자바에서 2차원 배열의 함정

- 자바의 `int[][]`는 **행 배열의 배열**입니다. `array[i]`는 **서로 다른 `int[]` 객체**이며, **물리적으로 연속 배치가 보장되지 않습니다**.
- 따라서 **열 우선 순회**(column-major) `array[i][j]`는 각 반복마다 **서로 먼 메모리**를 건드릴 수 있어 **캐시 미스**가 증가합니다.
- **행 우선 순회**(row-major) `array[i][j]`에서 **i 고정, j 증가** 패턴은 같은 `int[]`(연속 메모리)를 스캔하므로 **공간 지역성**을 최대화합니다.

---

## 3) 기본 개선: 루프 순서 교체

### 나쁜 예(열 우선)

```java
for (int j = 0; j < size; j++) {
  for (int i = 0; i < size; i++) {
    array[i][j]++;
  }
}
```

### 좋은 예(행 우선)

```java
for (int i = 0; i < size; i++) {
  int[] row = array[i];          // row 캐싱으로 간접 참조 감소
  for (int j = 0; j < size; j++) {
    row[j]++;
  }
}
```

- 내부 루프에서 `array[i]`를 **지역 변수에 보관**하여 **바운드 체크/간접 참조** 비용을 덜 수 있습니다.
- 단순 루프 교체만으로도 캐시 히트율 향상 → **대폭적인 실행 시간 단축**이 가능합니다.

---

## 4) 한 걸음 더: 1차원 플랫 배열 사용

- 구조를 `int[] flat = new int[size * size];`로 바꾸고, **인덱스 계산**으로 접근하면 **완전한 연속 메모리** 보장을 받을 수 있습니다.

```java
int size = 10240;
int[] flat = new int[size * size];

for (int i = 0; i < size; i++) {
  int base = i * size;           // 행 시작 오프셋
  for (int j = 0; j < size; j++) {
    flat[base + j]++;
  }
}
```

- 2차원 배열의 **객체 오버헤드/간접참조**를 제거해 **메모리 풋프린트**와 **캐시 지역성**을 함께 개선합니다.

---

## 5) 타일링(블로킹)으로 캐시 친화도 상승

- 큰 배열을 **타일(블록)** 로 쪼개어 연산하면 **작은 작업 집합**을 캐시에 오래 유지할 수 있습니다.

```java
int B = 64; // 블록 크기(실험으로 튜닝)
for (int ii = 0; ii < size; ii += B) {
  for (int jj = 0; jj < size; jj += B) {
    for (int i = ii; i < Math.min(ii + B, size); i++) {
      int[] row = array[i];
      for (int j = jj; j < Math.min(jj + B, size); j++) {
        row[j]++;
      }
    }
  }
}
```

- 행렬 곱셈, 컨볼루션 등에서도 **캐시 블로킹**은 핵심 최적화입니다.

---

## 6) 측정 시 주의사항(JVM/JIT)

- **워밍업**: JIT 최적화 전·후 성능이 다릅니다. 충분한 **미리 반복**을 수행한 뒤 측정하십시오.
- **정확한 시계**: 벤치는 `System.nanoTime()` 사용을 권장(`currentTimeMillis`는 해상도/정확도 낮음).
- **JMH 권장**: JVM 벤치마크는 **JMH(오라클/오픈JDK 공식 도구)** 로 작성하면 워밍업/측정/오차를 자동 관리합니다.
- **탈최적화 방지**: 결과를 사용하거나 **블랙홀(Blackhole)** 과 같은 기법으로 **죽은 코드 제거**를 방지해야 합니다.

### 간단 측정 예

```java
long t0 = System.nanoTime();
/* 작업 */
long t1 = System.nanoTime();
System.out.println("ns = " + (t1 - t0));
```

---

## 7) 기타 팁

- **배열 경계 검사** 최소화: 내부 루프에서 행 참조를 캐싱(`int[] row = array[i];`)하여 경계 검사와 간접 참조를 줄입니다.
- **병렬 처리**: 순서 독립 작업이면 `ForkJoinPool`/`parallel()`로 스레드 병렬화하되, **메모리 대역폭**이 병목이면 효과가 제한될 수 있습니다.
- **오프힙/Direct 버퍼**: 대용량 I/O 매핑 시 `MappedByteBuffer` 등으로 OS 페이지 캐시와의 상호 작용을 최적화할 수 있으나, 접근 패턴(연속성)이 여전히 핵심입니다.

---

## 8) 요약 체크리스트

- [ ] **행 우선 순회**로 공간 지역성을 살렸는가
- [ ] **간접 참조**를 줄이기 위해 행을 지역 변수로 캐싱했는가
- [ ] 가능하면 **1차원 플랫 배열**로 구조를 단순화했는가
- [ ] **타일링(블로킹)** 으로 캐시 친화도를 높였는가
- [ ] **JIT 워밍업**, **nanoTime/JMH**로 측정 신뢰성을 확보했는가

---

## 9) 최종 예시(개선본)

```java
public class LocalityTest {

  @Test
  void testRowMajor() {
    int size = 10240;
    int[][] array = new int[size][size];

    // 워밍업(간략 예)
    for (int w = 0; w < 3; w++) {
      for (int i = 0; i < size; i++) {
        int[] row = array[i];
        for (int j = 0; j < size; j++) {
          row[j]++;
        }
      }
    }

    long t0 = System.nanoTime();

    for (int i = 0; i < size; i++) {
      int[] row = array[i];
      for (int j = 0; j < size; j++) {
        row[j]++;
      }
    }

    long t1 = System.nanoTime();
    System.out.printf("수행시간(ns): %d%n", (t1 - t0));
  }
}
```

위 패턴은 **공간 지역성**을 최대한 활용하여 캐시 효율을 올립니다. 더 나아가 1차원 배열/타일링을 적용하면 대규모 데이터에서도 스케일이 잘 나옵니다.
