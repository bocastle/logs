# 코루틴이 스레드보다 가벼운 이유 정리 (Kotlin/JVM 중심)

> 본 문서는 Kotlin 코루틴과 전통적 스레드 모델을 대비하여 **메모리/스케줄링/전환 비용/차단 모델** 관점에서 설명합니다.

---

## 1) 메모리 사용량

- **스레드**
  - 각 스레드는 **자체 스택**을 가집니다. HotSpot JVM 기준 기본 스택 크기는 보통 **약 1MB** 전후(플랫폼/옵션에 따라 상이, `-Xss`로 조절 가능)입니다.
  - 스레드 생성 시 이 스택이 **예약**되고, 종료 시까지 유지됩니다.
- **코루틴**
  - 코루틴은 **스레드 내부에서 협력적으로 실행**되는 **경량 실행 단위**로, 고정 크기의 독립 스택을 갖지 않습니다.
  - **몇 KB 수준의 메타데이터 + 프레임(continuation)** 만을 힙에 보유하며, 일시 중단/재개 시 필요한 지역 상태만 캡처합니다.

> 결과: 같은 수의 작업을 수용할 때 **코루틴은 훨씬 적은 메모리**로 수천~수만 동시 작업을 수용할 수 있습니다.

---

## 2) 컨텍스트 스위칭 비용

- **스레드 전환(커널 스케줄러 개입)**
  - CPU 레지스터, 프로그램 카운터, 스택 포인터, TLB/캐시 국소성 손실 등 **OS 수준 문맥 교환** 비용이 큽니다.
  - 빈번한 전환은 **캐시 미스 증가**와 **스케줄러 오버헤드**를 유발합니다.
- **코루틴 전환(유저 공간)**
  - **일시 중단 지점(suspend)** 에서 **Continuation(다음 실행 위치 + 로컬 상태)** 을 힙에 저장하고, 다른 코루틴을 재개합니다.
  - 대개 **함수 호출/반환과 유사한 비용** 범주로, OS 스케줄러 개입이 없습니다.

> 결과: 같은 양의 I/O 중심 작업에서 **코루틴 전환이 훨씬 저렴**합니다.

---

## 3) 생성 및 관리 비용

- **스레드**
  - 생성은 **시스템 호출**과 커널 리소스 할당(스택/TCB 등)이 필요합니다.
  - 대량 생성은 **오래 걸리고** 실패 가능성도 높습니다(리소스 한계).
- **코루틴**
  - **객체 할당 수준**의 비용으로 빠르게 생성됩니다.
  - **구조화된 동시성(Structured Concurrency)** 로 부모-자식 범위를 통해 수명 관리가 간단합니다.

---

## 4) 차단 vs 일시 중단

- **스레드 블로킹**
  - `sleep`, 블로킹 I/O 등에서 **스레드 자체가 중단**되어 더 이상 유용한 일을 하지 못합니다.
- **코루틴 일시 중단**
  - `delay`, `suspend` I/O에서 **코루틴만 멈추고 스레드는 해제**되어 다른 코루틴을 실행합니다.
  - 동일 스레드 풀에서 **수천 개 코루틴**을 효율적으로 다중화(M:N 스케줄링)할 수 있습니다.

> 결과: **소수의 스레드**로 **다수의 코루틴**을 스케줄링하여 자원 효율이 극대화됩니다.

---

## 5) 코드 예시 비교

### 5.1 전통 스레드

```kotlin
// 1,000개의 스레드를 만들면 기본 스택 1MB 가정 시 예약 메모리만 약 1GB
for (i in 1..1_000) {
    Thread {
        Thread.sleep(1_000) // 스레드 자체가 블로킹
        println("Task $i completed")
    }.start()
}
```

### 5.2 코루틴

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(1_000) { i ->
        launch(Dispatchers.Default) {
            delay(1_000) // 코루틴만 일시 중단, 스레드는 다른 코루틴을 실행
            println("Task $i completed")
        }
    }
}
```

- 위 코루틴 예시는 **몇 MB 내외** 추가 메모리로 동등한 동시성을 구현 가능하며, 기본 디스패처가 보유한 **소수의 스레드**를 공유합니다.

---

## 6) 스케줄링 모델(M:N)

- **스레드 모델(N:1 또는 1:1)**: 애플리케이션 스레드 = OS 스레드(**1:1**) 매핑이 일반적.
- **코루틴 모델(M:N)**: **M개의 코루틴**이 **N개의 스레드**에 매핑되어 협력적으로 실행됩니다.
  - 런타임/디스패처가 **공정성(fairness)** 과 **부하 분산**을 관리합니다.
  - **스레드 전환 최소화**, **CPU 활용 극대화**.

---

## 7) 동기화 비용과 지역성

- **스레드 다수**는 경쟁 자원이 많아 **락 경합**과 **컨텍션(컨텐션)** 비용이 커집니다.
- **코루틴**은 동일 스레드 상에서 **순차적으로 재개**될 때가 많아 **락 필요성이 줄어들고**, 데이터 지역성이 좋아져 **캐시 효율**이 향상될 수 있습니다.
- Kotlin은 `Mutex`, `Channel`, `Flow` 등 **비차단 동기화 원시**를 제공하여 락 기반 설계보다 효율적 패턴을 지원합니다.

---

## 8) 주의할 점(코루틴이 항상 정답은 아님)

- **CPU 바운드 순수 계산**: 코루틴 자체가 성능을 올려주지 않습니다. **적절한 스레드 풀 크기**와 **병렬화 전략**이 중요합니다.
- **블로킹 API 호출**: `suspend`가 아닌 **블로킹 I/O**를 코루틴 문맥에서 호출하면 **스레드가 막힙니다**.
  - 해결: `withContext(Dispatchers.IO)`로 **블로킹 전용 스레드 풀**에서 실행하거나, 가능하면 **비동기 API** 사용.
- **JNI/네이티브 블로킹**: 외부 라이브러리의 **불가피한 블로킹**은 스레드 자원을 잠식합니다.
- **컨텍스트 오버유즈**: 과도한 디스패처 전환은 오버헤드를 야기합니다. **불필요한 `withContext`/`Dispatchers` 전환**을 줄이십시오.

---

## 9) 실전 설계 가이드

- **I/O 중심 대량 동시성**: 코루틴 우선. `suspend` API, `Flow`/`Channel`로 백프레셔·파이프라인 구성.
- **CPU 중심 작업**: `Dispatchers.Default` 크기 내에서 코루틴을 배치하거나, **전용 코루틴 디스패처**/워크 스틸링 풀로 제어.
- **블로킹 라이브러리 병행**: `Dispatchers.IO` 격리, 필요 시 **전용 스레드 풀**을 만들어 **쿼터링**.
- **구조화된 동시성**: 스코프-기반 수명 관리로 **누수/좀비 작업** 방지(`coroutineScope/supervisorScope`).

---

## 10) 요약

- **메모리**: 스레드(고정 스택) >> 코루틴(소형 프레임).
- **전환 비용**: OS 컨텍스트 스위치 >> 유저 공간 재개/일시 중단.
- **생성/관리**: 시스템 호출/커널 리소스 >> 객체 할당 수준.
- **차단 모델**: 스레드 차단 >> 코루틴 일시 중단(스레드 해제).
- **결론**: 특히 **I/O 바운드·대량 동시성**에서 **코루틴이 훨씬 가벼움**. 다만 **CPU 바운드/블로킹 네이티브**는 별도 전략 필요.
