# 디스크 접근 시간(Disk Access Time) 정리

## 1) 개념

디스크에서 특정 **데이터 블록**(여러 섹터의 집합)을 읽거나 쓸 때 걸리는 총 소요 시간. 일반적으로 아래의 합으로 표현합니다.

\[ T*{access} = T*{seek} + T*{rot} + T*{transfer} + T\_{controller_overhead} \]

- **T_seek (탐색 시간)**: 헤드를 목표 **트랙**으로 기계적으로 이동시키는 시간
- **T_rot (회전 지연 시간)**: 목표 **섹터**가 헤드 아래로 돌아올 때까지 기다리는 시간
- **T_transfer (전송 시간)**: 섹터/블록의 데이터를 컨트롤러 ↔ 메모리 사이로 전달하는 시간
- **T_controller_overhead**: 명령 처리, 큐잉, 인터럽트 처리 등 소프트웨어·펌웨어 오버헤드(보통 비교적 작음)

> 용어: **플래터(platter)**, **트랙(track)**, **섹터(sector)**, **실린더(cylinder=동일 반경 트랙 묶음)**

---

## 2) 각 성분의 특징과 근사식

### (1) 탐색 시간 T_seek

- 헤드 암을 원하는 트랙으로 이동시키는 **기계적** 동작
- 근사식: \( T*{seek} \approx T*{start} + \alpha \cdot d \) (d는 트랙 이동 거리, 구현에 따라 비선형)
- **지역성(locality)**이 높으면 평균 이동 거리가 줄어 **평균 T_seek**도 감소

### (2) 회전 지연 시간 T_rot

- 디스크 회전 속도가 **R RPM**일 때 **평균 회전 지연**은
  \[ T\_{rot,avg} = \frac{60}{R} \times \frac{1}{2} \]
  예) 7,200 RPM → 한 바퀴 = 8.33ms → 평균 4.17ms

### (3) 전송 시간 T_transfer

- 블록 크기를 **B**(byte), 연속 전송 속도를 **S**(byte/s)라 하면 \( T\_{transfer} = B / S \)
- 연속 전송 속도는 **트랙 저장 밀도·내/외곽 트랙 위치·버스 대역폭** 등에 영향

---

## 3) 수치 예시 (HDD)

- RPM = 7,200 → 평균 T_rot ≈ **4.17ms**
- 평균 T_seek ≈ **9ms** (소비자용 HDD 전형 값)
- 전송 속도 S = **150 MB/s**, 블록 B = **64 KB** → T_transfer ≈ **0.43ms**
- 컨트롤러 오버헤드 ≈ **0.1~0.3ms** (환경 의존)

**총 접근 시간** \(T\_{access}\) ≈ 9 + 4.17 + 0.43 + 0.2 ≈ **13.8ms**

> 동일 블록을 **순차**로 여러 개 읽으면(연속 배치), 첫 블록 이후에는 T_seek·T_rot가 거의 0에 수렴하므로 **T_transfer** 중심으로 지배 → 처리량 급증.

---

## 4) 랜덤 액세스가 느리고 순차 액세스가 빠른 이유

- **랜덤 접근**: 블록마다 트랙이 달라 **매번** T_seek + T_rot가 반복 → 기계적 지연 누적
- **순차 접근**: 인접 섹터/트랙을 연속 읽기 → 헤드 이동 최소화, 회전 대기 최소화 → **T_transfer**만 남아 **훨씬 빠름**

> 운영체제는 이를 활용해 **프리페치(읽기 선행)**, **페이지 캐시**, **파일 시스템의 순차 배치** 등을 적극 사용

---

## 5) SSD와의 비교

- **SSD**는 기계부가 없어 T_seek, T_rot ≈ **0** (수십~수백 μs 수준의 컨트롤러·플래시 지연이 지배)
- 따라서 **랜덤/순차 격차가 HDD보다 훨씬 작음.** 다만 큼직한 순차 전송은 **채널 병렬화**가 잘 활용되어 여전히 더 높은 처리량을 보이는 경향
- 내부 구현(FTL, 가비지 컬렉션, 쓰기 증폭)에 따라 **쓰기 지연·지터**가 발생 가능

---

## 6) 접근 시간 최적화 전략

### 하드웨어/펌웨어

- **NCQ/TCQ**(Native/Tagged Command Queuing): 요청을 재정렬해 평균 T_seek·T_rot 최소화
- **더 높은 RPM**(HDD), **더 많은 플래시 채널/웨이**(SSD): 회전 지연/병렬성 개선
- **큰 온드라이브 캐시(Write-back/Read cache)**: 단기 지역성 활용

### 운영체제/디스크 스케줄러

- **엘리베이터(LOOK/SCAN) 스케줄링**: 비슷한 실린더 요청을 묶어 헤드 왕복 최소화
- **읽기 선행(Sequential Read-ahead)**, **요청 병합(coalescing)**: 순차 패턴 증폭
- **파일 시스템 배치 최적화**(ext4, XFS 등): 메타데이터/데이터의 물리적 인접 배치
- **정렬(Alignment)**: 파티션·파일 시스템 블록을 물리 섹터/에라즈 블록 경계에 맞춤

### 애플리케이션 설계

- **순차 I/O 우선**: 로그 구조, 배치 쓰기, 큰 I/O 사이즈 사용(단, 소규모 I/O 지연 요구 시 트레이드오프)
- **배치 처리·버퍼링**: 작은 랜덤 I/O를 모아 큰 순차 I/O로 전환
- **작업 큐 깊이 적정화**: SSD는 **큐 깊이(QD)**가 처리량과 지연의 균형에 중요
- **데이터 레이아웃 최적화**: 핫셋을 캐시에 올리고, 콜드셋은 순차 스캔 우선

---

## 7) 체크리스트 (실무 점검 포인트)

- [ ] 워크로드가 **랜덤 중심**인지 **순차 중심**인지 파악했는가?
- [ ] 요청 **I/O 크기**가 지나치게 작아 전송 효율이 떨어지지 않는가?
- [ ] 디스크/SSD **스케줄러 및 큐잉** 옵션이 워크로드에 맞는가?
- [ ] 파일 시스템/파티션 **정렬**이 올바른가?
- [ ] **캐시/프리페치 정책**(DB 버퍼풀, OS 페이지 캐시, 스토리지 캐시)이 적절한가?
- [ ] HDD 환경이라면 **조각 모음/배치 최적화**가 필요한가? (서버·FS 종류에 따라 전략 상이)

---

## 8) 요약

- 디스크 접근 시간은 **탐색 + 회전 지연 + 전송 + 오버헤드**의 합
- HDD: **기계적 지연**(탐색·회전)이 지배 → **순차 > 랜덤**
- SSD: 기계 지연 없음 → **μs 급 지연**, 그래도 큰 순차 전송이 유리
- 최적화 핵심: **지역성 극대화, 순차화, 큐잉/스케줄링, 캐시 활용**
