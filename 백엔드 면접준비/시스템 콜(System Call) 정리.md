# 시스템 콜(System Call) 정리

## 1) 한 줄 정의

사용자 모드의 프로그램이 **운영체제 커널의 서비스**(파일 I/O, 프로세스 생성, 메모리 관리, 네트워킹 등)를 요청하기 위해 **특권 모드로 안전하게 진입**하는 표준화된 진입점.

---

## 2) 왜 필요한가

- **자원 보호**: 임의의 프로그램이 디스크/메모리/네트워크 장치를 직접 제어하면 전체 시스템 안정성이 무너질 수 있음.
- **동일 인터페이스**: 다양한 하드웨어와 드라이버를 커널이 추상화. 앱은 시스템 콜 집합만 알면 됨.
- **보안/감사**: 접근 제어(권한, ACL, capabilities), 감사 로깅, 네임스페이스/컨테이너 격리 등 정책 적용 지점.

---

## 3) 듀얼 모드와 실행 흐름

- **사용자 모드(User mode)**: 제한된 명령만 가능, 일반 애플리케이션 실행.
- **커널 모드(Kernel mode)**: 모든 특권 명령 가능, 커널 코드 실행.

### 전형적 흐름(간략 시퀀스)

1. 앱이 라이브러리 함수를 호출(예: `read()` → glibc wrapper).
2. 라이브러리가 **트랩/게이트**를 통해 커널 진입(`syscall`/`sysenter`/`int 0x80` 등).
3. CPU가 **커널 스택**으로 전환, **시스템 콜 번호 + 레지스터/스택 인자**를 커널 진입 루틴이 해석.
4. 커널이 **자원 권한 검사** 후 해당 서브시스템 실행(파일시스템/VM/네트워크 등).
5. 결과(리턴값/오류번호)를 유저 공간으로 돌려주고, **사용자 모드로 복귀**.

> 시스템 콜은 하드웨어 인터럽트와 다르며, **소프트웨어 트랩**에 의해 **동기적**으로 발생합니다.

---

## 4) 라이브러리 호출과의 차이

- **라이브러리 호출**: 유저 공간 내부에서의 일반 함수 호출(컨텍스트 전환 없음).
- **시스템 콜**: 커널 진입을 수반하는 **모드 전환** + 커널 코드 실행. 비용이 더 큼.
- 많은 표준 API는 **래퍼**입니다(예: `fread()`는 내부에서 `read()` 시스템 콜을 호출하거나 버퍼링을 추가).

---

## 5) 대표적 시스템 콜(리눅스 관점)

- **프로세스/스레드**: `fork`, `vfork`, `clone`, `execve`, `wait4`, `exit`, `setuid`
- **파일 I/O**: `openat`, `read`, `write`, `preadv/pwritev`, `close`, `fsync`, `stat`
- **메모리/VM**: `mmap`, `munmap`, `brk`, `mprotect`, `madvise`
- **네트워킹**: `socket`, `bind`, `listen`, `accept4`, `connect`, `sendmsg`, `recvmsg`
- **이벤트/비동기**: `epoll_*`, `select`, `poll`, `io_uring_setup`(근현대 비동기), `futex`
- **기타**: `ioctl`(장치 특수 제어), `clone3`, `prctl`, 네임스페이스 관련 `unshare`, `setns`

> 아키텍처마다 **시스템 콜 번호/ABI**가 다를 수 있음. glibc가 이를 추상화하고, 일부 시간 함수 등은 **vDSO**로 커널 진입 없이 제공되기도 함.

---

## 6) 비용과 최적화 포인트

- **모드 전환 오버헤드** + **컨텍스트 스위치** 가능성 → 과도한 시스템 콜은 성능 저하 유발.
- **최적화 전략**
  - 호출 **회수 줄이기**: 버퍼링(`fwrite`), 일괄 I/O(`readv/writev`, `sendmsg`, `splice`).
  - **제로-카피**: `sendfile`, `splice`, `mmap`으로 유저-커널 간 복사 최소화.
  - **이벤트 기반**: `epoll`/`io_uring`으로 N:1 대기, busy-wait/짧은 타임아웃 남발 지양.
  - **비동기화/배칭**: 네트워크/스토리지 요청을 합치고 대기 시간 은닉.
  - **핫패스 캐시**: 파일 디스크립터/경로 해시, 핫 데이터 `mmap` 등으로 캐시히트 상승.

---

## 7) 블로킹·논블로킹·비동기

- **블로킹**: `read`가 데이터 준비까지 **대기** → 스레드가 잠듦.
- **논블로킹**: 즉시 반환(EAGAIN) → `epoll` 등으로 준비되면 처리.
- **진정한 비동기(AIO/io_uring)**: 커널이 완료 시점에 알림/큐잉, 제출-완료 큐 기반.

---

## 8) 보안/격리와 시스템 콜

- **최소 권한**: 권한/캡빌리티 기반 접근 제어, 파일/네임스페이스 격리.
- **필터링**: `seccomp-bpf`로 허용된 시스템 콜만 통과시켜 공격면 축소.
- **감사/모니터링**: audit, eBPF로 호출 추적 및 정책 적용.

---

## 9) 다른 OS와의 관점

- **리눅스**: POSIX + 리눅스 고유 시스템 콜.
- **Windows**: 앱은 주로 Win32 API를 호출, 내부적으로 `ntdll`이 **NT 시스템 콜**을 트랩으로 진입.
- **macOS/BSD**: 유사한 POSIX 계열이지만 세부 ABI/번호는 다름.

---

## 10) 면접/실무 포인트 요약

- 시스템 콜은 **커널 서비스의 문**이며, 성능/보안의 핵심 접점.
- **호출 빈도 최소화**, **배칭/이벤트화**, **제로-카피**가 성능 키워드.
- **seccomp**, **네임스페이스**, **권한모델**로 공격면 축소.
- 라이브러리 호출과 **시스템 콜의 차이**, 듀얼 모드 전환 과정을 명확히 설명할 수 있어야 함.

---

## 11) 간단 예시(리눅스 x86-64 의사코드)

```c
// 유저 공간
ssize_t n = read(fd, buf, len); // glibc wrapper 내부에서
// rax=시스템콜번호, rdi/rsi/rdx... 로 인자 세팅 후 syscall 명령
```

```asm
; 커널 진입
syscall                      ; 트랩으로 커널 모드 진입
; 커널은 번호에 따라 sys_read 핸들러를 실행
; 권한/경로/캐시/페이지/디바이스 등 검증·처리 후
; 결과를 rax에 담아 사용자 모드로 복귀
```

---

## 12) 체크리스트

- [ ] 과도한 시스템 콜 호출 경로가 없는가(프로파일링: `strace`, `perf`)
- [ ] 블로킹 호출로 스레드가 불필요하게 잠들지 않는가
- [ ] 배칭/제로-카피/이벤트 대기 모델 적용 여부
- [ ] 보안 정책(seccomp, 캡빌리티, 네임스페이스) 적용 여부
- [ ] 라이브러리 버퍼링/캐시(vDSO 포함) 활용 여부
