# 시스템 간 비동기 연동 방식 정리

## 1) 개요

분리된 시스템을 느슨하게 결합하고 요청 지연을 줄이기 위해 비동기 연동을 사용합니다. 대표 방식은 **메시징 시스템 활용**, **데이터베이스 활용(테이블 폴링)**, **CDC(Change Data Capture)** 입니다. 각 방식의 동작, 장단점, 설계 시 고려사항을 정리합니다.

---

## 2) 메시징 시스템 활용 (Kafka, RabbitMQ 등)

### 동작

발신 시스템이 메시지를 브로커에 발행 → 수신 시스템이 구독/소비하여 처리.

### 장점

- 높은 처리량·확장성(파티셔닝/컨슈머 그룹).
- 프로듀서/컨슈머의 독립 배포·확장 용이.
- 재시도, 지연 큐, 재처리 등 운영 패턴 풍부.

### 단점·주의

- **메시지 유실/중복**에 대비 필요(퍼블리시 확인, 재시도 정책).
- **순서 보장**은 파티션/키 설계에 의존(키 단위 순서 보장, 전체 순서 어려움).
- **트랜잭션 이슈**: DB 쓰기와 메시지 발행의 원자성 보장이 어려움.
  - 해결: **Transactional Outbox 패턴**(서비스 DB에 outbox 테이블에 기록 → 별도 릴레이/커넥터가 브로커로 전달), **Idempotency Key** 설계.
- 운영 복잡도(브로커 클러스터, 모니터링, 스키마 진화 관리).

### 설계 팁

- 생산: 프로듀서 acks 설정, 배치·압축 옵션 조정.
- 소비: 멱등성 처리(비즈니스 키 기준 **중복 방지 저장소**), 재시도/보류 큐 설계.
- **스키마 레지스트리** 도입(호환성 규칙: backward/forward).

---

## 3) 데이터베이스 활용 (테이블 폴링)

### 동작

발신 시스템이 DB 테이블(예: `outbox` 또는 `events`)에 레코드 삽입 → 수신 시스템이 주기적으로 폴링하여 읽고 처리 후 상태 갱신.

### 장점

- 애플리케이션 트랜잭션과 **자연스러운 원자성** 확보(업무 데이터와 이벤트를 한 트랜잭션으로 커밋).
- 메시지 유실 우려가 낮고 **정확한 순서 관리** 용이(증가 키/타임스탬프 기준).

### 단점·주의

- **범용성/유연성 낮음**: 메시지 스키마 변경 시 DB 스키마 변경 동반.
- **폴링 부하/레이턴시**: 폴링 주기·배치 크기·인덱스 설계 필요.
- 보관/삭제 정책(보관 기간, 아카이브/파티셔닝) 수립 필요.

### 설계 팁

- 컬럼 예시: `id(pk, auto)`, `event_type`, `payload(json)`, `status`, `retry_count`, `next_retry_at`, `created_at`.
- 인덱스: `(status, next_retry_at)`, `(created_at)`.
- 소비 트랜잭션: 읽기→상태 전이(LOCK)→전송→성공/실패 마킹(지수 백오프).

---

## 4) CDC(Change Data Capture) 활용

### 동작

소스 DB의 변경 로그(binlog/redo)를 **로그 기반**으로 캡처 → 이벤트 스트림으로 내보내고 구독 시스템이 반영.

### 장점

- 애플리케이션 코드 단순화(별도 퍼블리시 코드 없이 DB 변경만으로 이벤트 발생).
- 트랜잭션 정합성·순서 보장(로그 시퀀스 기반).
- 변경 감지 범위가 넓음(여러 테이블/스키마).

### 단점·주의

- **의도/맥락 부족**: “왜 바뀌었는가”는 로그만으로 알기 어려움(비즈니스 이벤트로 가공 필요).
- DB 스키마 변경·대용량 테이블 리빌드 시 파이프라인 영향.
- 로그 보관·오프셋 관리, 재처리 전략 필요.

### 설계 팁

- Debezium 등 커넥터 사용, **스키마 변경 호환성** 정책 수립.
- 다운스트림에서 **도메인 이벤트**로 재구성(필요 필드 집계·변환).
- Exactly-once 추구 시: 파이프라인 멱등 설계 + 커밋/오프셋 일관 처리.

---

## 5) 선택 가이드(요약)

- **고처리량/확장성, 실시간 이벤트 스트리밍**이 핵심 → **메시징 시스템**.
- **업무 트랜잭션과 이벤트의 강한 원자성**이 가장 중요 → **DB 폴링(Outbox)**.
- **기존 시스템 변경 최소화, DB 변경 자체를 이벤트화** → **CDC**.
- 혼합 전략: 트랜잭셔널 아웃박스(DB) → CDC/커넥터로 Kafka 토픽에 전달.

---

## 6) 공통 고려사항

### 트랜잭션·원자성

- DB 쓰기 + 이벤트 발행의 원자성: **Outbox + Relay**, 또는 브로커의 **트랜잭션 프로듀스**.
- 소비 측 멱등성: 자연키/비즈니스 키 기반 **Idempotency Store**(처리 로그 테이블, TTL 캐시).

### 순서·중복·재시도

- 순서 보장 단위(키/파티션/테이블 키) 명확화.
- 재시도: 지수 백오프, **Poison Message** 격리(DLQ/DLT), 측면 경보.
- 타임아웃·모니터링: 처리 지연 SLA, 라그(consumer lag), 실패율 대시보드.

### 스키마·버전관리

- JSON/Avro/Protobuf 등 메시지 포맷, **Backward 호환** 우선.
- 필드 추가는 호환적, 필드 삭제/타입 변경은 마이그레이션 절차 수립.

### 보안·컴플라이언스

- PII 암호화/마스킹, 전송 암호화(TLS), 접근통제.
- 감사 로그, 재처리 시 감사 추적성 유지.

---

## 7) 간단 예시

### A) 트랜잭셔널 아웃박스 (DB 폴링)

```sql
-- 트랜잭션 내 업무 데이터 + 아웃박스 레코드 동시 커밋
BEGIN;
INSERT INTO orders (...) VALUES (...);
INSERT INTO outbox (event_type, payload, status, created_at)
VALUES ('OrderCreated', '{"orderId":123}', 'PENDING', NOW());
COMMIT;
```

폴링 워커는 `status='PENDING'`를 조회→전송→`status='SENT'`로 갱신. 실패 시 `retry_count` 증가 및 `next_retry_at` 재설정.

### B) Kafka 멱등 컨슈머 의사코드

```pseudo
for each message in topic(partition by key):
  if processed_store.contains(message.id): continue
  handle(message.payload)
  processed_store.save(message.id)  -- 트랜잭션 커밋
```

키 단위 순서를 유지하고, 중복 수신에도 안전합니다.

---

## 8) 체크리스트

- 목적/요구: 처리량, 지연, 순서, 정확성(exactly-once vs at-least-once), 운영 역량.
- 스키마 진화·버전 전략과 테스트(컨슈머 호환성 테스트).
- 장애/지연 감시 지표: lag, 리트라이율, DLQ 건수, end-to-end 지연.
- 재처리 계획: 오프셋 리셋/재구축 절차, 데이터 멱등 반영 가능성.
