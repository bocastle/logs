# InnoDB의 갭 락(Gap Lock)과 넥스트키 락(Next‑Key Lock), 그리고 팬텀 리드 방지

> 요약: **팬텀 리드(Phantom Read)** 는 같은 조건으로 두 번 조회할 때, 두 번째 조회에서 **새로 생긴 행**이 나타나는 현상입니다. InnoDB는 **MVCC 스냅샷 읽기**와 **갭 락/넥스트키 락이 적용된 잠금 읽기**를 통해 이를 방지합니다.

---

## 1) 팬텀 리드란

- 정의: 한 트랜잭션이 `WHERE` 조건으로 결과 집합을 읽은 뒤, **다른 트랜잭션의 삽입/삭제** 때문에 **같은 조건의 재조회**에서 **행 수가 달라지는** 현상.
- 예시

  ```sql
  -- 트랜잭션 A
  START TRANSACTION;
  SELECT * FROM orders WHERE amount > 150;  -- 2건

  -- 트랜잭션 B
  START TRANSACTION;
  INSERT INTO orders (customer_id, amount) VALUES (4, 250);
  COMMIT;

  -- 트랜잭션 A (같은 조건 재조회)
  SELECT * FROM orders WHERE amount > 150;  -- 추가 행이 보일 수 있음 (팬텀)
  ```

---

## 2) InnoDB의 격리 수준과 팬텀 리드 처리

- **REPEATABLE READ(기본)**
  - **일반 SELECT(일관 읽기)**: **MVCC 스냅샷**을 사용하여 **트랜잭션 시작 시점(또는 첫 일관 읽기 시점)** 의 일관된 뷰를 재사용합니다. 따라서 같은 트랜잭션 안에서 **새로 삽입된 행이 보이지 않아** 팬텀이 **사실상 방지**됩니다.
  - **잠금 읽기(SELECT … FOR UPDATE / LOCK IN SHARE MODE / UPDATE / DELETE)**: **갭 락/넥스트키 락**으로 **스캔 범위 내 삽입·수정**을 차단하여 **논리적 팬텀**을 방지합니다.
- **READ COMMITTED**
  - 일반 SELECT는 매 조회 시점의 스냅샷을 사용하므로 **팬텀이 관측될 수** 있습니다.
  - 잠금 읽기는 상황/검색 조건에 따라 **갭/넥스트키 락이 완화될 수** 있어, 설계 시 주의가 필요합니다.
- **SERIALIZABLE**
  - 읽기조차 잠금으로 직렬화하여 팬텀을 강하게 방지(대신 동시성 비용 증가).

> 실무 팁: **조회로 기준 집합을 확정**해야 하고 **후속 변경**을 안전히 수행하려면, **REPEATABLE READ + 잠금 읽기**를 사용하십시오.

---

## 3) 갭 락(Gap Lock)

- **정의**: **인덱스 레코드 사이의 간격(갭)** 을 잠그는 잠금. **존재하지 않는 키 공간**에 대한 **삽입**을 막습니다.
- **용도**: 범위 조건 검색 시, 해당 **범위 안으로 새로운 행이 끼어드는 것**을 방지 → **팬텀 리드 예방**.
- **특징**
  - **인덱스 기반**으로 동작(테이블 스캔이더라도 내부적으로 인덱스 경로를 결정).
  - 범위의 **양 끝 경계**는 상황에 따라 **오른쪽 개방(… , next] 형태)** 으로 잠금.
  - **행 자체 변경은 막지 않음**(그 역할은 레코드 락).

---

## 4) 넥스트키 락(Next‑Key Lock)

- **정의**: **레코드 락 + 갭 락**의 결합. 즉, **특정 인덱스 레코드**와 그 **바로 앞 갭**을 **하나의 잠금 단위**로 묶어 잠급니다.
- **효과**
  - 해당 **레코드의 갱신/삭제**와 **바로 인접 범위 삽입**을 **동시에** 제어.
  - 범위 검색 시 **스캔 구간 전체가 넥스트키 락 집합**으로 커버되어, **새로운 행의 끼어들기(팬텀)** 를 차단.

---

## 5) 동작 예시

### 5.1 갭 락 예

```
-- orders_id 인덱스에 1, 3, 5 존재
-- 트랜잭션 A
START TRANSACTION;
SELECT * FROM orders
 WHERE orders_id BETWEEN 2 AND 4
 FOR UPDATE;
-- → (1,3] 갭, 레코드 3, (3,5] 갭이 잠금: '4' 삽입 차단

-- 트랜잭션 B
START TRANSACTION;
INSERT INTO orders (orders_id, orders_amount) VALUES (4, 200);
-- → A가 커밋/롤백할 때까지 대기(갭 락 충돌)
```

### 5.2 넥스트키 락 예

```
-- 예시 데이터
-- orders_id | orders_amount
--     1     |     100
--     2     |     200
--     3     |     300

-- 트랜잭션 A
START TRANSACTION;
SELECT * FROM orders
 WHERE orders_amount = 200
 FOR UPDATE;
-- → amount=200에 해당하는 레코드(orders_id=2)의 레코드 락
--   + (amount 정렬상) 앞/뒤 갭이 함께 잠금(넥스트키)

-- 트랜잭션 B
START TRANSACTION;
INSERT INTO orders (orders_id, orders_amount) VALUES (4, 200);
-- → 해당 키 값이 속한 넥스트키 구간에 잠금 충돌로 대기
```

---

## 6) 팬텀 리드 방지 메커니즘 요약

1. **일관 읽기(MVCC)**
   - REPEATABLE READ에서 일반 SELECT는 **동일 스냅샷**을 사용 → 새로 삽입된 행이 보이지 않음.
2. **잠금 읽기 + 갭/넥스트키**
   - 범위에 대해 **삽입 자체를 차단** → 후속 동일 조건 조회에서도 **결과가 불변**.

> 즉, **보여주지 않게 하거나(스냅샷), 아예 못 끼어들게 하거나(갭/넥스트키)** 두 층으로 팬텀을 막습니다.

---

## 7) 주의사항·예외

- **인덱스가 핵심**: 범위 조건이 **인덱스에 부합**하지 않으면, 잠금 범위가 넓어지거나 의도대로 갭 제어가 안 될 수 있습니다. **적절한 보조 인덱스**를 설계하십시오.
- **유니크 동등 검색**: **고유 인덱스에 대한 동등 조건**은 **레코드 락만**으로 최적화될 수 있습니다(불필요 갭락 생략). 삽입 방지 범위가 달라질 수 있습니다.
- **READ COMMITTED**: 잠금 읽기에서 **갭/넥스트키가 완화**될 수 있으므로, **팬텀 차단이 요구되는 구간**은 **REPEATABLE READ + 잠금 읽기**를 권장합니다.
- **자동 증가 컬럼**: AUTO_INCREMENT는 **별도 잠금 규칙**이 적용되어 갭 제어와 동작이 다를 수 있습니다.
- **너무 넓은 범위 잠금 주의**: 과도한 범위 잠금은 **동시성 저하**와 **데드락 위험**을 키웁니다. 조건과 인덱스를 **정밀화**하십시오.

---

## 8) 체크리스트

- [ ] 팬텀을 막아야 하는 쿼리인가(집합 확정/후속 변경)?
- [ ] **REPEATABLE READ** 인가, 또는 그에 준하는 절차(트랜잭션 시작 시점 고정)?
- [ ] **잠금 읽기**를 사용했는가(`FOR UPDATE` / `LOCK IN SHARE MODE`)?
- [ ] 범위 조건이 **알맞은 인덱스**를 타는가(커버/선두 컬럼 설계)?
- [ ] 불필요한 광범위 갭 잠금을 피하도록 **조건을 축소**했는가?
- [ ] 데드락 대비 **일관된 잠금 순서**와 **타임아웃**을 설정했는가?

---

## 9) 결론

- **갭 락**은 **레코드 사이의 빈 공간**을 잠가 **삽입을 차단**,  
  **넥스트키 락**은 **레코드+인접 갭**을 묶어 **수정/삽입을 함께 제어**합니다.
- InnoDB는 **MVCC 스냅샷**(보이지 않게 함)과 **갭/넥스트키 잠금**(끼어들지 못하게 함)으로 **팬텀 리드**를 실무적으로 방지합니다.
- 팬텀 차단이 요구되는 트랜잭션에서는 **REPEATABLE READ + 적절한 인덱스 + 잠금 읽기**를 기본 가이드로 삼으십시오.
