# Redis가 싱글 스레드로 설계된 이유 정리

> 핵심: **간결한 동시성 모델로 일관성 보장 + 이벤트 루프 기반 I/O로 높은 처리량 확보**. 실행 코어는 단일 스레드로 직렬화하여 원자성을 보장하고, (Redis 6+) **네트워크 I/O는 멀티스레드화**되어 병목을 줄였습니다.

---

## 1) 왜 싱글 스레드인가

- **설계 단순화**: 잠금, 데드락, 레이스 컨디션 없이 직렬 실행 → 구현·디버깅 난이도와 운영 복잡도 감소.
- **데이터 일관성/원자성 보장**: 명령이 **순차적으로** 처리되어 복잡한 락 없이도 안전.
- **컨텍스트 스위칭 비용 최소화**: 다중 스레드 스케줄링/동기화 오버헤드 제거.
- **메모리 내 연산** 중심: 대부분의 작업이 RAM에서 O(1)~O(log N)로 빠르게 수행되어 단일 스레드만으로도 높은 QPS 달성.
- **이벤트 루프 기반**: 단일 스레드라도 **논블로킹** 네트워킹으로 동시 접속을 효율 처리.

```txt
Client requests → Event loop(ready FD) → Command queue → Single-thread execution → Reply
```

---

## 2) 이벤트 루프 + 논블로킹 I/O

- 소켓을 **논블로킹**으로 두고, `epoll/kqueue/select` 등으로 **준비된 소켓**만 처리.
- 처리 단위가 짧고 일관되어 **긴 요청이 전체를 독점**하지 않도록 명령 설계(예: SCAN, UNLINK 등).

---

## 3) 멀티스레드가 아닌 이유(일반론 대비 장점)

- **락 프리한 직렬 모델**: 공유 구조체 보호를 위한 미세 잠금/원자 연산 남발이 불필요.
- **캐시 친화성**: 자료구조가 단일 실행 흐름에 최적화되어 L1/L2 캐시 적중률 개선.
- **예측 가능한 지연 시간**: 스케줄링 가변성·우선순위 역전 등의 변수가 적음.

---

## 4) 단점과 보완

- **CPU 바운드 명령**(대용량 정렬/복잡 루아 스크립트/대형 RDB·AOF rewrite)은 단일 코어 한계에 영향.
  - 보완: 백그라운드 쓰기/압축/스냅샷 등은 **별도 프로세스/스레드**로 오프로딩, `LATENCY` 모니터링, 명령 사용 가이드(예: `SORT` 대신 `Z*` 자료구조), 키-샤딩.
- **멀티코어 활용 한계**: 하나의 인스턴스가 단일 실행 코어를 쓰므로, 멀티코어 활용은 **샤딩(클러스터)** 또는 **여러 인스턴스 수평 확장**으로 달성.

---

## 5) Redis 6 이후의 변화

- **I/O 스레드 도입**: 네트워크 **읽기/쓰기**는 멀티스레드로 병렬 처리하여 대용량 커넥션 환경의 I/O 병목 해소.
- **명령 실행은 여전히 단일 스레드**: core command path는 직렬 실행 → **원자성(Atomicity)** 보존.
- 효과: 고대역폭/느린 NIC, TLS, 큰 응답 버퍼 상황에서 **전송 지연 감소**.

```txt
I/O threads (read/write)  →  Single-thread command execution  →  I/O threads (send)
```

---

## 6) 언제 싱글 스레드가 특히 유리한가

- **주요 작업이 메모리 I/O 중심**이고, 요청이 짧고 많으며, 지연 변동성이 낮아야 하는 **캐시/세션/큐** 용도.
- 단순한 스키마(키-값, 정렬 집합, 해시 등)로 **락 없는 확정적 처리**가 필요한 경우.

---

## 7) 운영 팁

- **블로킹/대형 연산 회피**: `KEYS`, 큰 `LRANGE`, 대규모 `EVAL` 지양. 필요 시 배치/스트리밍/SCAN.
- **복제·내구성 작업 분리**: RDB/AOF rewrite는 백그라운드로, 디스크 I/O와 격리된 CPU/스토리지 고려.
- **스루풋 확장**: 코어 한계에 닿으면 **클러스터(샤딩)**, 멀티 인스턴스, 수평 확장 + 클라이언트 파티셔닝.
- **I/O 스레드 활용**: 고동시 접속·TLS·대용량 응답 환경에서는 `io-threads`, `io-threads-do-reads yes` 검토.
- **지연 원인 분석**: `LATENCY DOCTOR`, `SLOWLOG`, `MONITOR`로 outlier 파악.

---

## 요약

- Redis는 **단일 스레드 실행**으로 **일관성과 단순성**을 확보하고, **이벤트 루프**로 높은 동시성을 달성합니다.
- **Redis 6+**는 **I/O만 멀티스레드**로 병렬화하여 전송 병목을 줄였지만, **명령 실행은 단일 스레드**로 유지하여 **원자성/예측 가능성**을 지켰습니다.
- 멀티코어 활용은 **클러스터/샤딩**과 **여러 인스턴스**로 해결하는 것이 정석입니다.
