# CPU 스케줄링 정리

## 1) 개요

- **목적**: 제한된 CPU 자원을 여러 프로세스/스레드에 _합리적이고 공정하게_ 배분.
- **핵심 지표**
  - **응답 시간(Response Time)**: 최초 요청 후 첫 응답까지 시간(대화형 시스템 중요)
  - **대기 시간(Waiting Time)**: 준비 큐에서 대기한 총 시간
  - **반환 시간(Turnaround Time)**: 도착부터 완료까지 총 소요 시간(일괄 처리 중요)
  - **처리량(Throughput)**, **CPU 이용률(Utilization)**
- **분류**
  - **선점형(Preemptive)**: 타 프로세스가 실행 중인 프로세스를 _중단_ 가능
  - **비선점형(Non-preemptive)**: 실행 중인 프로세스가 **자발적으로** 양보/종료할 때까지 유지

---

## 2) 선점형 vs 비선점형

| 구분 | 선점형(Preemptive)                                     | 비선점형(Non-preemptive)                          |
| ---- | ------------------------------------------------------ | ------------------------------------------------- |
| 개념 | 우선순위/타임슬라이스 등으로 실행 **중단·교체** 가능   | **종료/대기 전환**까지 CPU 유지                   |
| 장점 | 짧은 응답시간, 대화형 작업에 유리, 급한 작업 우선 처리 | 컨텍스트 스위칭 적음, 단순, 예측 가능             |
| 단점 | 컨텍스트 스위칭 오버헤드, 경쟁/동기화 고려 필요        | 응답 지연, **호위 효과(convoy effect)** 발생 가능 |

---

## 3) 대표 스케줄링 알고리즘

### 3.1 FCFS (First-Come, First-Served) — 비선점형

- **원리**: 도착 순서대로 실행
- **장점**: 단순, 공정성 직관적
- **단점**: 긴 작업 뒤에 짧은 작업이 대기하는 **호위 효과**로 평균 대기/반환 시간 증가

### 3.2 SJF (Shortest Job First) — 비선점형

- **원리**: CPU 버스트(예상 실행 시간)가 가장 **짧은 작업** 우선
- **장점**: 평균 대기 시간 **최소화**(이론적 최적)
- **단점**: 실행 시간 **예측 필요**, 긴 작업의 **기아(starvation)** 가능

### 3.3 SRTF / SRT (Shortest Remaining Time First) — 선점형

- **원리**: 남은 시간이 **가장 짧은** 작업이 항상 실행
- **장점**: SJF의 장점 + 대화형에 유리, 평균 대기/반환 시간 개선
- **단점**: 잦은 선점으로 오버헤드, 기아 가능

### 3.4 RR (Round Robin) — 선점형

- **원리**: **타임 슬라이스(퀀텀)** 만큼 순환 실행
- **장점**: 응답 시간 향상, 공정성
- **단점**: 퀀텀이 **너무 작으면** 스위칭 오버헤드 증가, **너무 크면** FCFS 유사

> **퀀텀 선택 가이드**: 일반적으로 컨텍스트 스위칭 오버헤드의 10~20배 이상이 되도록 설정

### 3.5 Priority Scheduling — 선점형/비선점형

- **원리**: 우선순위 높은 작업 우선
- **장점**: 중요한 작업 선처리
- **단점**: **기아 현상** → **에이징(Aging)** 으로 완화(오래 기다리면 점진적 우선순위 상승)

### 3.6 Multilevel Queue (MLQ)

- **원리**: 우선순위/작업 유형별 **다중 준비 큐**(예: Foreground/Background) 운용, 큐 간 스케줄링 규칙 정의
- **특징**: 큐마다 서로 다른 알고리즘 적용 가능(RR, FCFS 등)

### 3.7 Multilevel Feedback Queue (MLFQ)

- **원리**: **피드백**으로 큐 **이동**. 새 작업은 상위 큐에서 짧은 퀀텀으로 실행, **CPU 많이 쓰면** 하위 큐로 강등, **오래 대기하면** 승급(에이징)
- **장점**: 추정 없이도 SJF 유사 행동, 대화형 친화적, 기아 완화
- **설계 포인트**: 큐 수/퀀텀 배수/승급·강등 정책

---

## 4) 알고리즘 선택 기준

- **대화형 시스템**: RR, 선점형 우선순위, MLFQ
- **일괄 처리(배치)**: SJF/SRTF가 평균 반환 시간 최소화에 유리
- **응답성 vs 처리량 트레이드오프**: 짧은 퀀텀은 응답성↑, 오버헤드↑
- **I/O-bound 우대**: 짧은 버스트를 빨리 처리하여 시스템 전반 효율↑

---

## 5) 실무 고려 사항

- **컨텍스트 스위칭 비용**: 레지스터·캐시·TLB 영향 포함
- **우선순위 역전(Priority Inversion)**: 낮은 우선순위가 가진 락 때문에 높은 우선순위가 대기 → **우선순위 상속**으로 완화
- **NUMA/멀티코어**: 코어 간 캐시 친화성, 스레드 **핀(pin)**, 부하 분산 고려
- **쓰로틀링/슬리핑**: 전력/열 정책과의 상호작용
- **실측 기반 튜닝**: 실제 워크로드의 버스트 길이, I/O 비율, 지표 목표에 따라 퀀텀·우선순위 정책 조정

---

## 6) 예시 비교 요약

| 알고리즘 | 선점 | 평균 대기/반환         | 응답성                | 공정성   | 위험/이슈           |
| -------- | ---- | ---------------------- | --------------------- | -------- | ------------------- |
| FCFS     | X    | 보통/나쁨(호위효과)    | 낮음                  | 중       | I/O-bound 불리      |
| SJF      | X    | 매우 우수(이론적 최소) | 낮음                  | 낮음     | 실행시간 추정, 기아 |
| SRTF     | O    | 우수                   | 중                    | 낮음     | 오버헤드, 기아      |
| RR       | O    | 보통                   | **높음**(퀀텀에 의존) | **높음** | 퀀텀 선택 중요      |
| Priority | O/X  | 가변                   | 가변                  | 낮음     | 기아 → 에이징       |
| MLQ      | O/X  | 가변                   | 가변                  | 가변     | 큐 간 불균형        |
| **MLFQ** | O    | **좋음**               | **좋음**              | 중       | 파라미터 튜닝 필요  |

---

## 7) 기아(Starvation)와 해결

- **원인**: 낮은 우선순위 작업이 지속적으로 밀림
- **해결**: **Aging**(오래 대기한 작업의 우선순위 점진 상승), MLFQ 승급 규칙

---

## 8) 한 줄 정리

- **대화형·즉시성**이 중요하면 **선점형(RR/MLFQ)**,
- **총 처리시간 최소화**가 중요하면 **SJF/SRTF**,
- **혼합 워크로드**면 **MLFQ**로 튜닝하되 **에이징**으로 기아를 완화합니다.
