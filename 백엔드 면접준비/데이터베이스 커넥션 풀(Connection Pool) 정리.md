# 데이터베이스 커넥션 풀(Connection Pool) 정리

> 커넥션 풀은 애플리케이션과 DB 간 **연결을 미리 만들어 재사용**함으로써 **지연을 줄이고**, **서버·DB 자원을 보호**하며, **처리량을 안정화**하는 핵심 인프라입니다. 커넥션 풀이 없거나 잘못 구성되면 **응답 지연**, **DB 최대 연결 초과**, **서버/DB 과부하**로 이어질 수 있습니다.

---

## 1) 커넥션 풀 미사용 시 발생 문제

1. **연결/해제 오버헤드**
   - 매 요청마다 TCP 핸드셰이크, 인증, 세션 초기화 → **지연 증가(p95/p99 악화)**.
2. **DB 최대 연결 초과(스파이크)**
   - 동시 요청마다 새 연결 시도 → DB `max_connections` 한계 도달 → **연결 실패/오류/DB 불안정**.
3. **리소스 낭비와 스로틀링 부재**
   - 애플리케이션이 **자체적으로 동시성 제한**을 못함(풀은 자연스러운 백프레셔 역할).
4. **준비문(Prepared Statement) 재사용 불가**
   - 연결마다 캐시 사라짐 → **파싱/플랜 비용 증가**.
5. **TLS/네트워크 비용 증폭**
   - TLS 핸드셰이크/키 교환 반복 → CPU/RTT 손해.
6. **연결 폭주로 DB 장애 전파**
   - 외부 장애 시 무제한 재시도 → DB 및 네트워크 **연쇄 장애**.

---

## 2) 커넥션 풀 사용 이점

- **지연/처리량 개선**: 연결 재사용으로 **고정 비용 제거**.
- **백프레셔**: 풀 가득 찰 때 **대기/거절 정책**으로 상류(애플리케이션)에서 **부하 완화**.
- **DB 보호**: **최대 동시 연결 수를 제한**하여 DB 안정성 확보.
- **자원 효율**: 준비문 캐시/세션 상태 재사용, TLS 세션 재활용.
- **관측성/제어**: 사용율, 대기 시간, 시간초과 등 **운영 지표** 확보.

---

## 3) 핵심 파라미터

- **initialSize / minimumIdle**: 기동 직후 지연 회피(워밍업).
- **maximumPoolSize**: 동시에 빌려줄 **최대 연결 수**(DB·애플리케이션·SLO 균형).
- **connectionTimeout**: 풀에서 **획득 대기 한도**(짧게; 예 100~300ms).
- **validation**: 커넥션 유효성 검사(아이들/빌려줄 때).
- **idleTimeout / maxLifetime**: 장수 연결 교체로 **스테일/네트워크 이슈 완화**.
- **leakDetectionThreshold**: 누수 진단(빌리고 반환하지 않는 코드 탐지).

---

## 4) “풀은 클수록 좋다?” — 사이징 원칙

풀 크기는 **스레드 수·쿼리 시간·DB 코어 수·워크로드 성격**을 함께 고려해야 합니다.

### 4.1 근사 가이드

- **I/O 바운드(DB가 대부분 기다림)**: `poolSize ≈ CPU 코어 수 × 2~4` (DB 측)
- **CPU 바운드(DB에서 계산 큼)**: `poolSize ≈ DB 코어 수` 수준으로 보수적
- **애플리케이션 스레드와의 균형**: `poolSize ≤ app 유효 동시 스레드 수` (크면 **유휴 연결 낭비**; 작으면 **대기**).

### 4.2 대기·처리량 관점(리틀의 법칙)

- 평균 동시 연결 필요량 `L ≈ λ × W`
  - λ: 초당 요청(데이터베이스에 도달)
  - W: DB 체류 시간(평균 쿼리 시간 + 대기)
- `L`을 초과해 풀을 키워도 **DB가 처리 못하면** 지연만 증가. 먼저 **쿼리/인덱스/캐시**를 튜닝하십시오.

### 4.3 상한 제약

- 너무 큰 풀 → **컨텍스트 스위칭/락 경합/버퍼 풀 압박**으로 **DB 성능 급락** 가능.
- 고가치/저가치 트래픽은 **풀 분리(벌크헤드)** 로 상호 영향 차단.

---

## 5) Spring Boot + HikariCP 예시

```yaml
spring:
  datasource:
    url: jdbc:postgresql://db:5432/app
    username: app
    password: secret
    hikari:
      maximum-pool-size: 30 # 서비스별·노드별로 산정
      minimum-idle: 5
      connection-timeout: 200ms # 풀 획득 대기 한도(백프레셔)
      idle-timeout: 600000 # 10분
      max-lifetime: 1800000 # 30분(로드밸런서/DB 타임아웃보다 약간 짧게)
      validation-timeout: 1000
      leak-detection-threshold: 2000 # 2s 이상 반납 지연 탐지(필요 시)
```

- **트랜잭션은 짧게**: 사용자 I/O/외부 API 호출을 트랜잭션 내부에 두지 마십시오(풀 점유).
- **읽기 전용 분리**: 리드 레플리카/읽기 전용 풀로 **읽기 부하 분산**.
- **장기 실행 쿼리 차단**: DB/ORM에서 **쿼리 타임아웃**(예 2~5s) 설정.

---

## 6) 운영 시나리오와 대처

1. **풀 고갈**(대기 급증, `connectionTimeout` 초과)
   - 원인: 느린 쿼리/락 경합/DB I/O 이슈/폭주.
   - 조치: **슬로우 쿼리** 분석·인덱스·실행계획 점검, 임시로 **동시성 하향/로드 셰딩**, 캐시 도입.
2. **DB 최대 연결 초과**
   - 원인: 여러 앱 인스턴스 합산 풀 크기 > DB 허용치.
   - 조치: **합산 상한**을 DB 설정 내로 유지, **풀 크기 자동화/환경 변수화**.
3. **연결 유휴/네트워크 단절**
   - 조치: **keepalive/validation**, `maxLifetime` < LB idle timeout.
4. **누수(반납 실패)**
   - 조치: `leakDetectionThreshold`, `try-with-resources`로 자동 반납.

---

## 7) 다중 서비스/멀티 테넌트 — 벌크헤드

- 서비스 별(또는 중요도 별)로 **풀을 분리**하여 장애 전파 차단.
- 읽기/쓰기, 배치/온라인 등 **워크로드 특성**별 분리도 효과적.

---

## 8) 성능·안정성 체크리스트

- [ ] 풀 합산 크기가 DB `max_connections`(또는 적정치) 이하인가
- [ ] `connectionTimeout`(풀 획득)과 **쿼리 타임아웃**이 설정되어 있는가
- [ ] `maxLifetime`/`idleTimeout`이 **네트워크/LB/DB 타임아웃**보다 약간 짧게 설정되었는가
- [ ] 슬로우 쿼리 로그/지표(p95/p99, 풀 사용률·대기시간)를 **지속 모니터링**하는가
- [ ] 고가치 경로는 **전용 풀(벌크헤드)** 을 사용하는가
- [ ] 트랜잭션을 **짧게 유지**하고 외부 호출을 내부에 두지 않는가
- [ ] 준비문 캐시/배치 쓰기 등 **연결 재사용 이점**을 활용하는가

---

## 9) 요약

- 커넥션 풀 미사용은 **매 요청 연결 비용**과 **무제어 동시성**으로 **지연·장애**를 유발합니다.
- 올바른 풀 구성은 **지연 감소**, **DB 보호**, **백프레셔**, **운영 가시성**을 제공합니다.
- 크기 설정은 **DB/애플리케이션/워크로드**를 함께 고려한 **절충**이며, **지속적인 관측과 튜닝**이 필수입니다.
