# Graceful Shutdown(우아한 종료) 정리

## 1) Graceful Shutdown이 필요한 이유

Graceful Shutdown은 서버가 종료될 때 **즉시 종료하지 않고**,

1. **새 요청을 받지 않도록 차단**하고
2. **이미 처리 중인 요청/작업을 마무리**한 뒤
3. **리소스를 정리하고 종료**하는 방식입니다.

즉시 종료(강제 종료)에 비해 다음 리스크를 줄입니다.

- **트랜잭션/데이터 무결성 문제 방지**
  - 처리 중이던 DB 트랜잭션이 중간에 끊기면 부분 반영/롤백 실패 등 비정상 상태가 생길 수 있습니다.
- **데이터 손실 방지**
  - 메시지 큐 컨슈밍, 파일 쓰기, 캐시 갱신, 배치 작업 등이 중단되면 유실/중복 처리로 이어질 수 있습니다.
- **사용자 경험(UX) 저하 방지**
  - 처리 중 요청이 갑자기 끊기면 5xx/타임아웃이 발생하고, 결제/작성/업로드 같은 핵심 플로우가 실패할 수 있습니다.
- **운영 안정성 향상**
  - 무중단 배포(롤링 업데이트), 오토스케일 인/아웃, 장애 조치(Failover)에서 안전하게 인스턴스를 내릴 수 있습니다.

일반적인 흐름은 다음과 같습니다.

1. 종료 신호 수신(SIGTERM 등)
2. **로드밸런서 헬스체크에서 제외**(드레인 시작) / 애플리케이션은 **새 요청 거부**
3. **진행 중 요청 완료 대기**(커넥션 드레인)
4. 스레드풀/큐/스케줄러 정리, DB 커넥션/파일 핸들/락 해제
5. 프로세스 종료

---

## 2) SIGTERM vs SIGKILL

리눅스/유닉스에서 프로세스를 종료할 때 대표적으로 사용하는 시그널입니다.

- **SIGTERM(15)**
  - “정상적으로 종료해라”는 **종료 요청**에 가깝습니다.
  - 프로세스가 **시그널을 핸들링**할 수 있어, Graceful Shutdown 로직(드레인/정리)을 수행할 수 있습니다.

- **SIGKILL(9)**
  - 프로세스를 **즉시 강제 종료**합니다.
  - **핸들링 불가**(정리 로직 실행 기회 없음).
  - 최후의 수단이며, 데이터/상태 유실 위험이 큽니다.

---

## 3) 스프링(Spring)에서 Graceful Shutdown 설정

Spring Boot는 서버 커넥션 드레인 기반의 Graceful Shutdown을 설정으로 지원합니다.

```properties
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=20s
```

- `server.shutdown=graceful`
  - 종료 시 **새 커넥션/요청을 받지 않고**, 처리 중인 요청을 마무리하도록 동작합니다.
- `spring.lifecycle.timeout-per-shutdown-phase`
  - Graceful Shutdown이 **무한히 대기**하지 않도록 **최대 대기 시간**을 둡니다.
  - 예: 데드락/무한루프/외부 의존성 지연으로 요청이 끝나지 않으면, 타임아웃 후 종료될 수 있습니다.

---

## 4) 운영 관점 체크리스트(자주 놓치는 부분)

- 로드밸런서/인그레스에서 **드레인(Draining)** 지원 여부 및 타임아웃 설정
- 애플리케이션 레벨에서 **새 요청 거부**(503, connection close 등) 시점
- 긴 요청(대용량 업로드/리포트 생성/스트리밍) 처리 정책
- 메시지 컨슈머/배치 작업: **중단 시 재처리/중복 처리** 전략(ack, offset, idempotency)
- 종료 타임아웃을 서비스 특성에 맞게 조정(너무 짧으면 실패, 너무 길면 배포 지연)
