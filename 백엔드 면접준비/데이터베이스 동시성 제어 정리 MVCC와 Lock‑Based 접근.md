# 데이터베이스 동시성 제어 정리 — MVCC와 Lock‑Based 접근

> 요약: **MVCC**는 트랜잭션별 **스냅샷(다중 버전)** 을 제공하여 읽기·쓰기 충돌을 줄이고, **Lock‑Based**는 **잠금**으로 순서를 강제하여 일관성을 보장합니다. InnoDB 등 현대 엔진은 두 방식을 **혼용**해 성능과 정합성을 동시에 달성합니다.

---

## 1) 배경: 왜 동시성 제어가 필요한가

- 다중 트랜잭션 동시 실행 시 **Dirty Read / Non‑Repeatable Read / Phantom Read** 등의 이상 현상이 발생할 수 있습니다.
- 동시성 제어의 목표는 **직렬 실행과 동등한 결과(Serializability)** 를 최대한 보장하면서 **처리량과 응답시간**을 확보하는 것입니다.

---

## 2) MVCC(Multi‑Version Concurrency Control)

### 개념

- **행 버전(undo/버전 체인)** 을 유지하고, 각 트랜잭션은 **자기 시점의 스냅샷**으로 읽습니다.
- **일반 SELECT(일관 읽기)** 는 **잠금 없이** 버전 가시성 규칙으로 결과를 구성합니다.

### 장점

- 읽기 작업이 쓰기와 **경합하지 않음** → 읽기 지연·락 대기 최소화.
- **REPEATABLE READ**에서 동일 트랜잭션 내 조회 결과가 **안정**(스냅샷 고정).
- 읽기 많은 워크로드에서 **처리량 증가**.

### 단점/주의

- **여러 버전 보관 비용**(저장공간/가비지 정리).
- 매우 높은 쓰기율에서는 버전 관리·청소 비용이 증가.
- 스냅샷만으로는 **논리적 팬텀**을 완전히 제어하지 못하므로, **잠금 읽기**가 필요할 수 있습니다.

### 간단 흐름

```
TxA 시작 → 스냅샷 시점 고정
TxB가 행 X 갱신/삽입 → 새로운 버전 생성
TxA는 여전히 자신의 스냅샷 기준으로 X 읽기(락 없음)
```

---

## 3) Lock‑Based Concurrency Control(잠금 기반)

### 개념

- **공유(읽기) 락** / **배타(쓰기) 락** 등으로 **접근 순서를 직·간접 강제**합니다.
- 2PL(2‑Phase Locking) 변형들이 널리 사용됩니다.

### 장점

- 제어가 **명시적**이고 단순하며, 충돌 시 **직접 차단**으로 정합성 확보 용이.
- 갭/넥스트키 등 **범위 잠금**으로 **팬텀**까지 방지 가능.

### 단점/주의

- 락 경합 시 **대기·타임아웃·데드락** 위험.
- 읽기까지 락을 요구하면 **병렬성 저하**.

### 간단 흐름

```
TxA: 레코드/범위 잠금 획득 → 작업 → 커밋 시 해제
TxB: 동일 자원 요청 시 대기(또는 타임아웃/롤백)
```

---

## 4) InnoDB에서의 혼용 전략(실무 포인트)

| 시나리오                              | 메커니즘                         | 효과                                |
| ------------------------------------- | -------------------------------- | ----------------------------------- |
| 일반 SELECT(일관 읽기)                | **MVCC 스냅샷**                  | 읽기 락 없이 높은 동시성            |
| SELECT … FOR UPDATE / UPDATE / DELETE | **레코드 락 + 갭/넥스트키 락**   | 삽입·갱신 충돌 및 **팬텀** 방지     |
| 범위 조회 후 후속 변경                | **REPEATABLE READ + 잠금 읽기**  | 기준 집합을 고정하고 사이 삽입 차단 |
| READ COMMITTED에서 충돌 제어          | **잠금 읽기(필요 시 범위 잠금)** | 즉시성은 높지만, 잠금 설계 주의     |

- **갭 락**: 인덱스 **사이 공간**을 잠가 **삽입 차단**.
- **넥스트키 락**: **레코드 락 + 앞 갭**을 묶어 범위 내 **갱신·삽입 동시 제어**.
- 효과: MVCC가 **“보이지 않게”** 막고, 갭/넥스트키가 **“끼어들지 못하게”** 막습니다.

---

## 5) 이상 현상과 격리 수준 요약

| 격리 수준                     | Dirty Read | Non‑Repeatable |                                                          Phantom | 특징/비고                     |
| ----------------------------- | ---------: | -------------: | ---------------------------------------------------------------: | ----------------------------- |
| READ UNCOMMITTED              |       발생 |           발생 |                                                             발생 | 거의 사용하지 않음            |
| READ COMMITTED                |       방지 |      발생 가능 |                                                        발생 가능 | Oracle 기본, 조회 최신성 높음 |
| REPEATABLE READ (InnoDB 기본) |       방지 |           방지 | **스냅샷 읽기에서 사실상 방지**, 잠금 읽기 시 갭/넥스트키로 제어 | 실무 밸런스 우수              |
| SERIALIZABLE                  |       방지 |           방지 |                                                             방지 | 동시성 비용 큼                |

---

## 6) 선택 가이드

- **읽기 중심 서비스**: MVCC 친화(캐시·리드 레플리카·REPEATABLE READ + 일반 SELECT).
- **정확한 집합 보장 후 변경**: `FOR UPDATE`/`LOCK IN SHARE MODE`로 **범위 잠금** 확보.
- **충돌이 잦은 쓰기**: 잠금 범위를 **세분화**(적절한 인덱스/샤딩/행 단위 설계).
- **지연 허용 낮음**: READ COMMITTED + 부분 모킹/큐 기반 비동기로 경합 완화.
- **감사/금융 등 강한 정합성**: SERIALIZABLE 또는 업무 단위의 **순차 처리/큐잉**.

---

## 7) 실무 체크리스트

- [ ] 팬텀/경합을 유발하는 **범위 조건**에 **인덱스**가 적절한가
- [ ] 기준 집합을 확정해야 하는 시점에 **잠금 읽기**를 사용했는가
- [ ] **락 대기 시간/타임아웃**과 **재시도 정책**을 정의했는가
- [ ] **데드락** 대비: 락 획득 **순서 일관화**, 짧은 트랜잭션, 필요 최소 범위
- [ ] MVCC 잔존 버전의 **청소(UNDO/GC)** 로 장기 트랜잭션을 관리하는가
- [ ] 읽기·쓰기 트래픽을 **분리**(CQRS/레플리카)했는가

---

## 8) 결론

- **MVCC**는 **읽기 성능과 동시성**을, **Lock‑Based**는 **명시적 충돌 제어**와 **강한 정합성**을 제공합니다.
- InnoDB 등 현대 엔진은 **두 방식을 결합**하여, 읽기는 **락 없이**, 변경은 **정밀한 잠금**으로 다룹니다.
- 핵심은 **격리 수준 선택 + 인덱스/범위 설계 + 잠금 전략**을 업무 특성에 맞게 조합하는 것입니다.
