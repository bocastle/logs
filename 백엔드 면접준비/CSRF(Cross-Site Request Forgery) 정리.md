# CSRF(Cross-Site Request Forgery) 정리

## 1) CSRF란?

- **CSRF(사이트 간 요청 위조)**는 사용자가 **의도하지 않았는데도**, 사용자의 **인증 정보(주로 쿠키/세션)**가 자동으로 포함된 요청을 이용해 공격자가 원하는 행위를 **피해 사이트에 수행**시키는 공격입니다.
- 핵심 포인트는 **“요청이 사용자의 브라우저에서 나가므로 인증이 붙는다”**는 점입니다.

## 2) 동작 흐름(전형적인 시나리오)

1. 사용자가 피해 사이트에 로그인 → 서버가 **세션 쿠키**를 발급(Set-Cookie)
2. 사용자는 로그인 상태 유지(브라우저가 이후 요청에 쿠키 자동 첨부)
3. 공격자가 사용자를 악성 페이지로 유도(메일/게시글/링크 등)
4. 악성 페이지가 **피해 사이트로 요청을 발생**(예: 이미지/폼/스크립트 요청)
5. 브라우저가 쿠키를 자동으로 붙여 전송 → 서버는 정상 사용자 요청으로 오인 가능

예시(의도치 않은 요청 트리거):

```html
<img src="https://victim.example.com/member/changePassword?newValue=1234" />
```

## 3) CSRF가 성립하기 쉬운 조건

- 인증이 **쿠키 기반(세션/쿠키 토큰)**이고, 브라우저가 **자동으로 쿠키를 첨부**하는 구조
- 서버가 **요청의 출처/의도**를 확인할 추가 검증이 없는 경우
- 상태 변경(결제/비밀번호 변경 등)이 **GET**처럼 쉽게 트리거되는 요청으로 노출되어 있는 경우(안티패턴)

## 4) 방어 방법(실무에서 많이 쓰는 것 위주)

### A. CSRF 토큰(가장 정석)

- 서버가 사용자 세션(또는 별도 저장소)에 **난수 토큰**을 저장하고,
- 폼/요청에 **hidden input** 또는 헤더로 토큰을 함께 보내게 한 뒤,
- 서버에서 **세션의 토큰과 요청의 토큰을 비교**해 일치할 때만 처리합니다.

예시(폼):

```html
<input type="hidden" name="csrf_token" value="random_token_value" />
```

> SPA의 경우도 토큰을 meta 태그로 내려주거나, 서버에서 토큰 발급 API를 제공하고
> 요청 시 `X-CSRF-Token` 같은 헤더로 보내는 방식으로 동일하게 적용할 수 있습니다.

### B. SameSite 쿠키(매우 효과적, 기본값으로 많이 사용)

- `Set-Cookie`에 `SameSite`를 설정해 **크로스 사이트 요청에 쿠키가 자동 전송되는 것을 제한**합니다.
- 일반적으로:
  - `SameSite=Lax`: 대부분의 일반 CSRF를 크게 줄임(기본값인 경우 많음)
  - `SameSite=Strict`: 가장 강함(다만 UX 제약 가능)
  - `SameSite=None; Secure`: 크로스 사이트 쿠키 허용(필요 시에만), HTTPS 필수

### C. Origin/Referer 검증(보조 수단)

- 요청 헤더의 **Origin**(가능하면 Origin 우선) 또는 **Referer**를 확인해
  서버의 Host(또는 허용 목록)와 매칭되는지 검사합니다.
- 한계:
  - Referer는 환경/정책에 따라 누락되거나 축소될 수 있음
  - 단독 방어로 두기보다는 **토큰/SameSite와 함께** 쓰는 편이 안전합니다.

### D. “상태 변경은 POST/PUT/DELETE + JSON” 같은 설계(구조적 완화)

- 상태 변경을 GET으로 두지 않고, 폼/JSON 바디를 요구하게 설계하면
  단순 `<img>` 같은 트리거로는 공격이 어려워집니다.
- 다만 **이것만으로 CSRF가 완전히 해결되지는 않으므로** 토큰/SameSite와 함께 적용합니다.

## 5) CORS/SOP와의 관계(자주 헷갈리는 포인트)

- **SOP/CORS는 ‘응답을 읽는 것’을 통제**하는 성격이 강합니다.
- CSRF는 “요청 자체가 나가는 것”과 “쿠키가 붙는 것”이 핵심이라,
  **CORS만으로 CSRF가 해결되지 않습니다.**
- CSRF 방어는 **요청이 ‘정상 출처에서 의도적으로 발생했다’**는 것을 증명하는 메커니즘(토큰/Origin 검증 등)이 필요합니다.

## 6) 한 줄 결론

- CSRF는 **“로그인된 사용자의 브라우저를 이용해”** 서버에 **의도치 않은 상태 변경 요청**을 보내는 공격이고,
- 실무 방어는 보통 **SameSite 쿠키 + CSRF 토큰(필요 시 Origin 검증 보조)** 조합이 가장 안정적입니다.
