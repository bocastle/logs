# CQRS(Command Query Responsibility Segregation) 패턴 정리

## 1) CQRS란?

CQRS는 **상태를 변경하는 작업(Command)** 과 **데이터를 조회하는 작업(Query)** 을 **서로 다른 모델(또는 계층/구현)** 로 분리하는 아키텍처 패턴입니다.

- **Command(명령)**: Create/Update/Delete처럼 **상태를 바꾸는 요청**
- **Query(조회)**: Read처럼 **상태를 조회해서 보여주는 요청**

예) `Order` 리소스를 다룰 때

- **명령 모델**: `Order` (도메인 규칙/불변식 중심, 변경을 안전하게 수행)
- **조회 모델**: `OrderData` (화면/리포트에 최적화된 데이터 형태)

---

## 2) 왜 분리하나요?

시스템은 보통 다음 특성이 다릅니다.

- **쓰기(명령)**: 트랜잭션/정합성/도메인 규칙이 중요
- **읽기(조회)**: 빠른 응답/필터링/정렬/조인/집계가 중요

한 모델로 모두 해결하려고 하면,  
도메인 모델이 조회 요구 때문에 비대해지거나(복잡도 증가),  
조회 성능이 쓰기 설계에 의해 제약을 받는 문제가 생길 수 있습니다.

---

## 3) CQRS의 장점

### (1) 유지보수성 향상

- 변경 로직(명령)과 조회 로직(쿼리)이 분리되어 **각각 단순해짐**
- 도메인 모델이 조회 요구에 끌려다니지 않고 **규칙/불변식 유지에 집중**

### (2) 성능/기술 선택의 유연성

- 명령 모델: 정합성/트랜잭션이 강한 **RDB + JPA**
- 조회 모델: 조회 성능이 강한 **NoSQL/캐시/검색엔진**, 또는 **SQL 최적화(MyBatis 등)**
- 같은 DB를 쓰더라도,
  - **Command**는 JPA로 도메인 중심 구현
  - **Query**는 MyBatis/Native SQL로 조회 성능 최적화  
    같은 “혼합 전략”이 가능합니다.

### (3) 확장성

- 조회 트래픽이 쓰기보다 훨씬 큰 경우, 조회 쪽만 별도로 확장하기 쉬움

---

## 4) CQRS의 단점/주의점

### (1) 구현 복잡도 증가

- 모델/코드/레이어가 늘어나 **구현량이 증가**
- 팀이 패턴을 이해하지 못하면 오히려 혼란이 커질 수 있음

### (2) (특히 분산 CQRS에서) 동기화/정합성 문제

- 명령 모델의 변경을 조회 모델로 전파해야 할 수 있음
- 이벤트 기반으로 동기화하면 **최종적 일관성(Eventual Consistency)** 을 고려해야 함  
  (조회가 약간 늦게 반영될 수 있음)

### (3) 운영/관찰성(Observability) 요구 증가

- 데이터 흐름이 늘어나면 장애 분석/추적이 어려워져
  로깅/모니터링/트레이싱 설계가 중요해짐

---

## 5) 언제 도입하면 좋을까?

- **조회 요구가 매우 복잡**(다양한 필터/정렬/조인/집계, 화면별 DTO가 다름)
- **조회 트래픽이 압도적으로 큼**(읽기 확장이 핵심)
- 도메인 규칙이 강하고, 단일 모델로 유지하면 **도메인 모델이 조회 요구로 오염**되는 경우
- 읽기/쓰기에서 **서로 다른 저장소/기술**을 쓰는 것이 명확히 이득인 경우

도입 판단 기준(감각적으로):

- “단일 모델 유지 비용” vs “분리로 인한 복잡도 비용”을 비교해서,
  **분리했을 때 얻는 이득(성능/단순화/확장)이 확실할 때** 도입하는 것이 좋습니다.

---

## 6) 한 줄 요약

CQRS는 **쓰기(명령)와 읽기(조회)의 책임을 분리**해서  
각각을 **더 단순하고 더 최적화 가능**하게 만드는 패턴이지만,  
그만큼 **구현/운영 복잡도가 늘어** 도입은 신중해야 합니다.
