# 응집도(Cohesion)와 결합도(Coupling) 정리

## 1) 응집도(Cohesion)

- **정의**: 하나의 모듈(클래스/패키지/컴포넌트) 내부 요소들이 **얼마나 한 목적을 위해 밀접하게 관련**되어 있는지.
- **높은 응집도(좋음)**의 신호
  - 모듈의 변경 이유가 **하나(또는 매우 소수)**로 수렴함. (Single reason to change)
  - 메서드들이 **서로의 데이터를 공유/협력**하며 하나의 개념을 완성함.
  - “이 클래스는 무엇을 담당하나?”에 한 문장으로 답하기 쉬움.
- **낮은 응집도(나쁨)**의 신호
  - 서로 무관한 기능이 한곳에 섞여 있음(예: `UserService`가 인증/메일/통계/파일업로드까지 다 함).
  - 변경 요구가 올 때마다 같은 파일/클래스가 계속 자주 수정됨(변경의 중심이 됨).
- **효과**
  - 높은 응집도는 **수정 범위를 최소화**하고, 테스트/리팩토링을 쉽게 만듦.

## 2) 결합도(Coupling)

- **정의**: 한 모듈이 다른 모듈에 **얼마나 의존**하는지, 그리고 **상대 모듈의 내부 지식을 얼마나 많이 알아야** 하는지.
- **낮은 결합도(좋음)**의 신호
  - 의존 대상의 **구현 세부사항**이 바뀌어도 호출자는 영향이 작음.
  - 인터페이스/추상화(계약)만 알고 사용함.
  - 데이터 구조를 깊게 파고들지 않음(“점을 찍는” 접근이 적음).
- **높은 결합도(나쁨)**의 신호
  - 다른 모듈의 내부 필드/자료구조/예외/상태 전이까지 알아야 함.
  - 한 곳 변경 시 연쇄 수정이 발생함(수정 파일이 도미노처럼 늘어남).
  - 특정 구현체에 강하게 묶임(예: 코드 곳곳에서 특정 DB/특정 프레임워크 API에 직접 의존).

## 3) “높은 응집도 + 낮은 결합도”가 좋은 설계인 이유

- 변경은 항상 발생하고, 비용은 **변경 범위**에 비례함.
- **응집도↑** → 변경이 “해당 모듈 내부”로 모임.
- **결합도↓** → 변경이 “다른 모듈로 전파”되지 않음.
- 결과적으로 **유지보수성, 배포 안정성, 테스트 용이성**이 좋아짐.

## 4) 캡슐화(Encapsulation)와의 관계

- **캡슐화**: 객체/모듈의 **변경 가능성이 큰 내부 세부사항을 숨기고**, 안정적인 인터페이스만 노출하는 것.
- 캡슐화가 좋아지면
  - 내부 구현을 모듈 안에 가두어 **응집도는 자연히 올라가고**
  - 외부가 내부를 몰라도 되므로 **결합도는 내려감**
- 즉, 실무에서 “응집도/결합도 개선”은 대개 **캡슐화 강화**로 시작하는 게 효과적임.

## 5) 실무에서 바로 쓰는 체크리스트

### 응집도 체크

- 이 모듈이 바뀌는 이유가 몇 개인가?
- 메서드들이 동일한 도메인 개념(한 책임)을 구성하는가?
- 파일/클래스 이름이 실제 하는 일과 맞는가?

### 결합도 체크

- 의존하는 모듈의 내부 구조를 너무 많이 아는가?
- 한 모듈 변경이 다른 모듈 수정으로 자주 이어지는가?
- 의존 관계가 “인터페이스(계약)” 중심인가, “구현체” 중심인가?

## 6) 짧은 예시(감 잡기)

- **나쁜 예(높은 결합도)**: `order.getUser().getAddress().getZip()` 처럼 깊게 타고 들어가며 내부 구조에 의존.
- **개선 방향**: `order.getShippingZip()` 처럼 필요한 정보를 **Order의 책임**으로 끌어와 내부를 감춤(캡슐화).

---

필요하시면 “응집도/결합도 개선 리팩토링 패턴(예: Facade, DTO 경계, Service 분리, 인터페이스 도입)”도 함께 정리해드릴 수 있습니다.
