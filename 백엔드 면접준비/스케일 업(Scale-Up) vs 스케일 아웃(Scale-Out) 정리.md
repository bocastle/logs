# 스케일 업(Scale-Up) vs 스케일 아웃(Scale-Out) 정리

> 요약: **스케일 업**은 단일 서버의 **사양을 상향**하여 성능을 끌어올리는 전략이며, **스케일 아웃**은 **동일·유사 사양의 서버 대수**를 늘려 트래픽을 분산하는 전략입니다. 목표 지표(지연, 처리량, 가용성), 어플리케이션 구조, 비용 모델을 기준으로 선택하시는 것을 권장드립니다.

---

## 1) 정의

- **스케일 업**: 기존 인스턴스의 **CPU/메모리/스토리지/네트워크 대역폭**을 상향.  
  예: EC2 `t3.micro → t3.large`, RDS 인스턴스 클래스 업그레이드.
- **스케일 아웃**: **복수 인스턴스**를 추가하고 **로드 밸런싱**으로 트래픽 분산.  
  예: Auto Scaling Group으로 웹 서버 수평 확장, 캐시 노드 샤딩.

---

## 2) 장단점 비교

| 항목             | 스케일 업                    | 스케일 아웃                             |
| ---------------- | ---------------------------- | --------------------------------------- |
| 적용 난이도      | **낮음**(사양 변경/리스타트) | **중간~높음**(LB, 세션, 배포, 상태관리) |
| 성능 확장성      | 하드웨어 상한선 존재         | 이론상 선형(아키텍처 의존)              |
| 가용성/장애 대응 | 단일 노드 의존, SPOF 위험    | 노드 다중화로 **가용성↑**               |
| 비용 모델        | 단위 인스턴스 단가 급증 가능 | 필요 시점에 **점증적 비용**             |
| 상태/세션 관리   | 단일 노드라 단순             | 세션 스티키/외부 세션 저장 필요         |
| 데이터 계층      | 수직 확장 쉬움(캐시/DB도 업) | 샤딩/리플리케이션 등 설계 필요          |
| 배포/업데이트    | 단일 노드 영향 큼            | 롤링/블루그린 가능, 무중단 용이         |

---

## 3) 어떤 상황에 어떤 전략이 적합한가

### 스케일 업을 우선 고려

- 애플리케이션이 **상태(Stateful)** 이고 분산이 어렵거나, **단일 쓰레드/코어 성능**이 병목인 경우
- **단기 피크 대응/신속한 완화**가 필요할 때
- 데이터베이스처럼 수평 분할 전에 **메모리/스토리지 상향**으로 캐시 적중률을 높일 수 있을 때

### 스케일 아웃을 우선 고려

- **무상태(Stateless) 웹/API 서버**로 쉽게 복제 가능
- **가용성/내결함성** 요구가 높고, 무중단 배포가 필요
- 트래픽 변동이 커서 **오토스케일링**으로 비용 탄력화가 유리
- 리드-헤비 워크로드(읽기 복제/캐시로 분산) 또는 파티셔닝 가능한 계산 작업

---

## 4) 설계 체크리스트

### 스케일 업

- 인스턴스/스토리지 **상한선**과 단위 비용 곡선 확인(“스펙 급증 대비 가격 급증” 구간 존재)
- 업/다운 규모 변경 시 **재시작/다운타임** 요건 검토
- 단일 노드 장애 대비 **백업/복구/스냅샷/RTO·RPO** 계획

### 스케일 아웃

- **로드 밸런서** 도입(ALB/NLB/GCLB) 및 **헬스체크**
- **세션/상태 외부화**: Redis 세션 저장, 토큰 기반 인증, 업로드 파일은 오브젝트 스토리지(S3/GCS)
- **데이터 계층 분산**: 읽기 복제(Read Replica), 샤딩, CQRS, 캐시 계층(Memcached/Redis)
- **오토스케일링**: 정책(지표: CPU, QPS, 지연), 콜드 스타트 대비 웜업, 최소/최대 용량
- **무중단 배포**: 롤링/블루그린/카나리, 헬스·드레인·연결 유지
- **관찰 가능성**: 지표(에러율, p95 지연, 스로틀링), 로그 집계, 트레이싱

---

## 5) 데이터베이스 관점

- **업(Vertical)**: 메모리 증설로 **버퍼 풀/페이지 캐시** 확대 → 디스크 I/O 절감, 단기 효과 큼
- **아웃(Horizontal)**:
  - 읽기 분산: **Read Replica**, 캐시 핫셋 분리
  - 쓰기 분산: **샤딩/파티셔닝**(키 설계, 크로스샤드 트랜잭션·조인 고려)
  - **페일오버** 자동화: HA 구성, 프롬펫/라이트프로모션 지연 관리

---

## 6) 비용·운영 관점의 의사결정 프레임

1. **병목 유형** 파악: CPU/메모리/네트워크/스토리지/DB 락/외부 의존성
2. **목표 SLO**: 가용성(예: 99.9%), 지연 목표(p95, p99), 처리량(QPS)
3. **아키텍처 제약**: 상태성, 강한 일관성 요구, 트랜잭션 범위
4. **성숙도·운영 여력**: 관측·배포·온콜 체계가 아웃 확장을 감당 가능한가
5. **TCO**: 인프라 + 운영 인건비 + 장애 비용(다운타임, 데이터 유실 리스크)

---

## 7) 실무 예시 시나리오

- **초기 서비스**: 스케일 업으로 신속 대응 → CPU/메모리 여유 확보 후 **장기적으로 무상태화** 및 오토스케일링 도입
- **피크 트래픽 이벤트(프로모션)**: Auto Scaling Group으로 **사전 워밍** + 캐시/ CDN 적극 활용
- **리포트/배치 서버**: 병렬성 높은 워크로드는 노드 병렬(스케일 아웃) + 큐/워크 스틸링
- **DB 쓰기 병목**: 먼저 **인덱스/쿼리/스키마 최적화** → 수직 확장 → 필요 시 파티셔닝/샤딩

---

## 8) 결론

- **스케일 업**은 빠르고 단순하지만 상한과 SPOF 리스크가 있습니다.
- **스케일 아웃**은 가용성과 확장성에서 유리하지만, 상태 분리·데이터 분산·운영 복잡성이 수반됩니다.
- 단계적으로 **업 → 아웃**으로 진화하면서, **무상태화·캐시·오토스케일링·무중단 배포**를 기반으로 비용과 가용성을 균형 있게 달성하시길 권장드립니다.
