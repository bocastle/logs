# 일급 컬렉션(First-Class Collection) 정리

> 하나의 컬렉션을 **의미 있는 도메인 타입**으로 감싸서, 관련 **불변성(검증)**과 **비즈니스 규칙**을 한곳에서 보장하는 설계 패턴입니다.

---

## 1) 정의

- **일급 컬렉션**은 `List`, `Set`, `Map`과 같은 컬렉션을 **그 자체로 노출하지 않고**, 별도의 클래스로 감싸 **도메인 개념**을 부여합니다.
- 내부 컬렉션은 **캡슐화**하고, 외부에는 필요한 **도메인 메서드만** 공개합니다.
- 가능하면 **불변(immutable)** 으로 설계하여, 의도치 않은 변경을 차단합니다.

---

## 2) 왜 사용하는가(효과)

1. **의미 부여와 응집도 향상**: `List<Order>` 대신 `Orders`로 **도메인 언어**를 드러내고, 관련 로직을 한곳에 모읍니다.
2. **불변성과 무결성 보장**: 생성 시 검증, 수정 시 규칙 강제(최소/최대 크기, 중복 금지 등).
3. **인터페이스 축소**: 모든 `List` API를 노출하지 않고 **필요한 연산만** 허용(단일 책임 원칙 강화).
4. **중복 제거**: 합계/평균/정렬/필터링 같은 **흔한 도메인 연산**을 재사용.
5. **테스트 용이**: 경계가 명확해지고, **불변 규칙**을 단위 테스트로 쉽게 보장.
6. **리팩터링 내성**: 내부 자료구조 변경이 외부에 **누수되지 않음**.

---

## 3) 기본 설계 원칙

- **불변**을 기본값으로: 내부 컬렉션은 `unmodifiable` 뷰 또는 **복사본**을 유지합니다.
- **캡슐화**: 컬렉션 자체를 반환하지 않고, 필요한 연산 메서드로만 노출합니다.
- **검증 내재화**: 생성자/팩토리에서 **중복, null, 크기 제한** 등의 규칙을 검사합니다.
- **도메인 연산 제공**: 합치기, 교집합, 필터링 등 **업무 의미**가 드러나는 API를 제공합니다.
- **값 타입 지향**: `equals`/`hashCode` 를 **내용 기반**으로 구현하여 **값 동치**를 보장합니다.

---

## 4) Java 예시

```java
public final class Orders {

    private final List<Order> values;

    public Orders(List<Order> values) {
        List<Order> copy = List.copyOf(values == null ? List.of() : values);
        validate(copy);
        this.values = copy;
    }

    private void validate(List<Order> list) {
        if (list.stream().anyMatch(o -> o == null)) {
            throw new IllegalArgumentException("Order cannot be null");
        }
        if (list.size() > 1000) {
            throw new IllegalArgumentException("Too many orders");
        }
        // 중복 금지 규칙이 있다면 여기에서 검사
        // Set<OrderId> ids = ...
    }

    public int size() { return values.size(); }

    public List<Order> asList() {
        return values; // 불변 리스트(List.copyOf)라 외부에서 수정 불가
    }

    public Orders add(Order order) {
        if (order == null) throw new IllegalArgumentException("Order cannot be null");
        List<Order> next = new ArrayList<>(values);
        next.add(order);
        return new Orders(next); // 불변: 새로운 인스턴스 반환
    }

    public Money totalAmount() {
        return values.stream()
                .map(Order::amount)
                .reduce(Money.zero(), Money::plus);
    }

    public Orders filter(Predicate<Order> predicate) {
        return new Orders(values.stream().filter(predicate).toList());
    }

    @Override public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Orders other)) return false;
        return values.equals(other.values);
    }
    @Override public int hashCode() { return values.hashCode(); }
    @Override public String toString() { return "Orders" + values; }
}
```

> 불변 컬렉션을 유지하기 위해 `List.copyOf`를 사용했습니다. 가변 API가 필요하면 **명시적 메서드**로만 허용하고, 내부 상태 일관성을 유지하십시오.

---

## 5) Kotlin 예시

```kotlin
@JvmInline
value class Orders private constructor(private val values: List<Order>) {

    val size: Int get() = values.size
    fun toList(): List<Order> = values // 읽기 전용 List

    fun add(order: Order): Orders =
        of(values + order)

    fun totalAmount(): Money =
        values.fold(Money.zero()) { acc, o -> acc + o.amount }

    companion object {
        fun of(input: List<Order>): Orders {
            val copy = input.filterNotNull()
            require(copy.size <= 1000) { "Too many orders" }
            return Orders(copy)
        }
        fun empty(): Orders = Orders(emptyList())
    }
}
```

---

## 6) JPA와의 연동 시 주의점

- **엔티티 컬렉션 필드**를 그대로 노출하지 말고, **일급 컬렉션 타입**으로 감싸되 JPA 매핑은 **엔티티 내부**에서 처리합니다.
  - 예: `@OneToMany private List<Order> ordersInternal;` 를 두고, 외부에는 `Orders` 타입을 반환/설정하는 **어댑터 메서드**를 둡니다.
- **지연 로딩** 컬렉션을 그대로 노출하면 **변경 가능 컬렉션**이 퍼집니다. 변환 시 **복사본/불변 뷰**를 사용하십시오.
- 동등성 비교/직렬화 시 **프록시**와의 상호작용을 고려하십시오.

---

## 7) 언제 도입하면 좋은가

- 컬렉션과 관련된 **도메인 규칙**(중복 금지, 최소/최대 크기, 정렬 규칙, 합계/집계)이 반복될 때
- 특정 컬렉션이 **자주 등장**하고, 매번 같은 **검증/연산**을 수행할 때
- 외부로 컬렉션이 노출되어 **사이드 이펙트**가 발생하는 문제가 있을 때

---

## 8) 도입 시 흔한 실수

- **내부 컬렉션을 그대로 반환**: 캡슐화가 깨지고, 외부에서 임의 수정 가능
- **불변 보장 실패**: `Collections.unmodifiableList`만 쓰고 내부 참조를 공유해 **우회 변경** 허용
- **DTO와 뒤섞기**: 도메인 모델의 일급 컬렉션과 전송용 DTO 컬렉션을 **명확히 분리**하지 않음
- **규칙 누락**: 생성자에서 핵심 검증을 빼먹어 **불변식이 깨짐**
- **남용**: 의미 없는 래핑(단순 전달)만 하고 실질적 규칙/가치가 없을 때는 오히려 복잡도만 증가

---

## 9) 체크리스트

- [ ] 컬렉션에 **도메인 의미**가 있는가? (이름이 분명한가)
- [ ] **불변성**과 **검증**이 생성 시점에 보장되는가
- [ ] 외부에 **원본 컬렉션을 노출하지** 않는가
- [ ] 필요한 **도메인 연산**(합계·정렬·필터)을 제공하는가
- [ ] `equals`/`hashCode`가 **내용 기반**으로 올바르게 동작하는가
- [ ] JPA/직렬화/매퍼와의 **경계**가 명확한가

---

## 10) 요약

- 일급 컬렉션은 **컬렉션을 도메인 객체로 승격**하여 **불변성·검증·응집도**를 확보하는 설계입니다.
- 내부 구조는 감추고 **의미 있는 연산만** 노출하며, 가능하면 **불변**으로 유지하십시오.
- 반복되는 규칙과 연산을 일급 컬렉션에 모으면 **안정성**과 **가독성**, **테스트 용이성**이 크게 향상됩니다.
